---
slug: phat-trien-rock-paper-scissors-nang-cao
title: 'Ph√°t Tri·ªÉn Rock-Paper-Scissors N√¢ng Cao - Tournament v√† AI Th√¥ng Minh'
authors:
  - behitek
tags:
  - game-development
  - console-game
  - python
  - rock-paper-scissors
  - ai
  - tournament
  - statistics
description: >-
  N√¢ng c·∫•p game Rock-Paper-Scissors t·ª´ c∆° b·∫£n th√†nh h·ªá th·ªëng tournament ho√†n ch·ªânh v·ªõi AI th√¥ng minh, th·ªëng k√™ chi ti·∫øt v√† nhi·ªÅu ch·∫ø ƒë·ªô ch∆°i th√∫ v·ªã.
keywords: [rock paper scissors python, game k√©o b√∫a bao, AI game python, tournament system, machine learning game]
image: /img/blog/generated/phat-trien-rock-paper-scissors-nang-cao-thumbnail.jpg
---

Rock-Paper-Scissors (K√©o-B√∫a-Bao) t∆∞·ªüng ch·ª´ng ƒë∆°n gi·∫£n nh∆∞ng ·∫©n ch·ª©a nhi·ªÅu b√†i h·ªçc th√∫ v·ªã v·ªÅ l·∫≠p tr√¨nh AI, ph√¢n t√≠ch pattern, v√† x√¢y d·ª±ng h·ªá th·ªëng tournament. Trong b√†i n√†y, ch√∫ng ta s·∫Ω ph√°t tri·ªÉn m·ªôt phi√™n b·∫£n n√¢ng cao v·ªõi AI th√¥ng minh c√≥ th·ªÉ h·ªçc h·ªèi t·ª´ l·ªëi ch∆°i c·ªßa b·∫°n!

D·ª± √°n n√†y s·∫Ω d·∫°y ch√∫ng ta v·ªÅ machine learning c∆° b·∫£n, pattern recognition, statistical analysis, v√† c√°ch x√¢y d·ª±ng m·ªôt h·ªá th·ªëng game ho√†n ch·ªânh t·ª´ A ƒë·∫øn Z.

<!-- truncate -->

## Game Demo v√† Gi·ªõi Thi·ªáu

H√£y c√πng xem phi√™n b·∫£n n√¢ng cao c·ªßa Rock-Paper-Scissors:

```
üéÆ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ROCK-PAPER-SCISSORS CHAMPIONSHIP ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê üéÆ

üèÜ Tournament Mode: Round Robin (8 players)
ü§ñ AI Level: Expert (Adaptive Learning)
üìä Current Match: Player vs SmartAI

Round 15/20 
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     YOU         ‚îÇ    SMART AI     ‚îÇ
‚îÇ      ‚úÇÔ∏è         ‚îÇ       üóø        ‚îÇ
‚îÇ   (Scissors)    ‚îÇ     (Rock)      ‚îÇ
‚îÇ                 ‚îÇ    üèÜ WINS!     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üìà Pattern Analysis:
   Your tendency: Rock(35%) > Scissors(35%) > Paper(30%)
   AI Prediction: Rock (Confidence: 78%)
   
üíØ Score History: W-L-W-L-L-W-W-L-W-W-L-W-W-L-L
üéØ Win Rate: 53% | AI Win Rate: 47%

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

1. üóø Rock      3. üìä View Stats
2. üìÑ Paper     4. üéØ Strategy Hint  
3. ‚úÇÔ∏è Scissors  5. üîÑ Change AI Level

Your choice: 
```

## B·∫°n S·∫Ω H·ªçc ƒê∆∞·ª£c G√¨?

Qua d·ª± √°n n√¢ng cao n√†y, b·∫°n s·∫Ω th√†nh th·∫°o:

- [x] **AI v√† Machine Learning**: Pattern recognition, adaptive algorithms
- [x] **Data Analysis**: Statistical analysis, trend prediction  
- [x] **Tournament Systems**: Round robin, elimination brackets
- [x] **Advanced OOP**: Strategy pattern, factory pattern, observer pattern
- [x] **Performance Optimization**: Caching, efficient data structures
- [x] **Visualization**: ASCII charts, progress bars, animated displays

## Y√™u C·∫ßu Tr∆∞·ªõc Khi B·∫Øt ƒê·∫ßu

- **Python trung c·∫•p**: OOP, decorators, generators
- **Math c∆° b·∫£n**: Statistics, probability
- **Thu·∫≠t to√°n**: Understanding c·ªßa sorting, searching

:::info Game Modes S·∫Ω X√¢y D·ª±ng
üéØ **Classic Mode**: Ch∆°i ƒë∆°n v·ªõi AI  
üèÜ **Tournament Mode**: Gi·∫£i ƒë·∫•u nhi·ªÅu ng∆∞·ªùi/AI  
üìä **Training Mode**: AI h·ªçc t·ª´ l·ªëi ch∆°i c·ªßa b·∫°n  
ü§ñ **AI Battle**: Xem c√°c AI ƒë·∫•u v·ªõi nhau  
üìà **Analytics Mode**: Ph√¢n t√≠ch chi ti·∫øt patterns
:::

## Ph·∫ßn 1: Ph√¢n T√≠ch H·ªá Th·ªëng N√¢ng Cao

### Game Flow Architecture

```mermaid
flowchart TD
    A[Start Application] --> B[Main Menu]
    B --> C{Choose Mode}
    C -->|Classic| D[Single Game vs AI]
    C -->|Tournament| E[Tournament Setup]
    C -->|Training| F[AI Training Mode]  
    C -->|Analytics| G[View Statistics]
    
    D --> H[Select AI Difficulty]
    H --> I[Play Rounds]
    I --> J[Update Stats]
    J --> K{Continue?}
    K -->|Yes| I
    K -->|No| B
    
    E --> L[Choose Tournament Type]
    L --> M[Add Participants]
    M --> N[Run Tournament]
    N --> O[Show Results]
    O --> B
    
    F --> P[AI Learning Phase]
    P --> Q[Test Learned Patterns]
    Q --> R[Export AI Model]
    R --> B
    
    G --> S[Generate Reports]
    S --> T[Display Charts]
    T --> B
```

### Component Architecture

```mermaid
classDiagram
    class GameEngine {
        -current_mode: str
        -tournament_manager: TournamentManager
        -ai_manager: AIManager
        -stats_tracker: StatsTracker
        +start_game()
        +switch_mode()
        +save_session()
    }
    
    class Player {
        -name: str
        -stats: PlayerStats
        -strategy: Strategy
        +make_move()
        +update_stats()
        +get_pattern()
    }
    
    class AIPlayer {
        -difficulty: int
        -learning_model: LearningModel
        -pattern_analyzer: PatternAnalyzer
        +predict_opponent_move()
        +adapt_strategy()
        +train_model()
    }
    
    class TournamentManager {
        -participants: list
        -tournament_type: str
        -bracket: Bracket
        +create_tournament()
        +run_round()
        +determine_winner()
    }
    
    class PatternAnalyzer {
        -move_history: list
        -patterns: dict
        +analyze_sequence()
        +predict_next_move()
        +calculate_confidence()
    }
    
    class StatsTracker {
        -global_stats: dict
        -session_stats: dict
        +record_move()
        +generate_report()
        +export_data()
    }
    
    GameEngine --> TournamentManager
    GameEngine --> AIPlayer
    GameEngine --> StatsTracker
    Player <|-- AIPlayer
    AIPlayer --> PatternAnalyzer
    TournamentManager --> Player
```

## Ph·∫ßn 2: Core Game Implementation

### B∆∞·ªõc 1: Base Classes v√† Enums

```python
from enum import Enum
import random
import time
from collections import defaultdict, deque
from abc import ABC, abstractmethod
import json
from datetime import datetime
import statistics

class Move(Enum):
    """Enum cho c√°c n∆∞·ªõc ƒëi"""
    ROCK = "üóø"
    PAPER = "üìÑ" 
    SCISSORS = "‚úÇÔ∏è"
    
    def beats(self, other):
        """Ki·ªÉm tra n∆∞·ªõc ƒëi n√†y c√≥ th·∫Øng n∆∞·ªõc ƒëi kh√°c kh√¥ng"""
        winning_combinations = {
            Move.ROCK: Move.SCISSORS,
            Move.PAPER: Move.ROCK,
            Move.SCISSORS: Move.PAPER
        }
        return winning_combinations[self] == other
    
    def __str__(self):
        return self.value

class GameResult(Enum):
    """K·∫øt qu·∫£ c·ªßa m·ªôt round"""
    WIN = "WIN"
    LOSE = "LOSE"  
    DRAW = "DRAW"

class AILevel(Enum):
    """M·ª©c ƒë·ªô AI"""
    RANDOM = "Random"
    BASIC = "Basic Pattern"
    INTERMEDIATE = "Frequency Analysis"
    ADVANCED = "Markov Chain"
    EXPERT = "Adaptive Learning"
    MASTER = "Deep Pattern Recognition"

class PlayerStats:
    """Class theo d√µi th·ªëng k√™ c·ªßa ng∆∞·ªùi ch∆°i"""
    
    def __init__(self, name="Player"):
        self.name = name
        self.total_games = 0
        self.wins = 0
        self.losses = 0
        self.draws = 0
        self.move_history = deque(maxlen=1000)  # Gi·ªØ 1000 n∆∞·ªõc ƒëi g·∫ßn nh·∫•t
        self.move_counts = {Move.ROCK: 0, Move.PAPER: 0, Move.SCISSORS: 0}
        self.win_streaks = []
        self.current_streak = 0
        self.longest_streak = 0
        self.session_start = datetime.now()
    
    def record_game(self, my_move, opponent_move, result):
        """Ghi l·∫°i k·∫øt qu·∫£ m·ªôt game"""
        self.total_games += 1
        self.move_history.append((my_move, opponent_move, result, datetime.now()))
        self.move_counts[my_move] += 1
        
        if result == GameResult.WIN:
            self.wins += 1
            self.current_streak += 1
            self.longest_streak = max(self.longest_streak, self.current_streak)
        elif result == GameResult.LOSE:
            self.losses += 1
            if self.current_streak > 0:
                self.win_streaks.append(self.current_streak)
                self.current_streak = 0
        else:
            self.draws += 1
    
    def get_win_rate(self):
        """T√≠nh t·ª∑ l·ªá th·∫Øng"""
        if self.total_games == 0:
            return 0
        return (self.wins / self.total_games) * 100
    
    def get_move_distribution(self):
        """Ph√¢n b·ªë c√°c n∆∞·ªõc ƒëi"""
        if self.total_games == 0:
            return {move: 0 for move in Move}
        
        return {
            move: (count / self.total_games) * 100 
            for move, count in self.move_counts.items()
        }
    
    def get_recent_pattern(self, length=10):
        """L·∫•y pattern g·∫ßn ƒë√¢y"""
        if len(self.move_history) < length:
            return [move for move, _, _, _ in self.move_history]
        return [move for move, _, _, _ in list(self.move_history)[-length:]]
    
    def to_dict(self):
        """Chuy·ªÉn th√†nh dictionary ƒë·ªÉ l∆∞u file"""
        return {
            'name': self.name,
            'total_games': self.total_games,
            'wins': self.wins,
            'losses': self.losses,
            'draws': self.draws,
            'move_counts': {move.name: count for move, count in self.move_counts.items()},
            'longest_streak': self.longest_streak,
            'session_start': self.session_start.isoformat()
        }
```

### B∆∞·ªõc 2: Pattern Analysis Engine

```python
class PatternAnalyzer:
    """AI engine ph√¢n t√≠ch pattern c·ªßa ƒë·ªëi th·ªß"""
    
    def __init__(self):
        self.move_history = deque(maxlen=100)
        self.sequence_patterns = defaultdict(lambda: defaultdict(int))
        self.frequency_analysis = {Move.ROCK: 0, Move.PAPER: 0, Move.SCISSORS: 0}
        self.markov_chain = defaultdict(lambda: defaultdict(int))
        self.adaptation_rate = 0.1
    
    def record_move(self, move):
        """Ghi l·∫°i n∆∞·ªõc ƒëi c·ªßa ƒë·ªëi th·ªß"""
        self.move_history.append(move)
        self.frequency_analysis[move] += 1
        
        # C·∫≠p nh·∫≠t Markov chain
        if len(self.move_history) >= 2:
            prev_move = self.move_history[-2]
            self.markov_chain[prev_move][move] += 1
        
        # Ph√¢n t√≠ch sequence patterns (2-4 moves)
        for seq_len in range(2, min(5, len(self.move_history) + 1)):
            if len(self.move_history) >= seq_len:
                sequence = tuple(list(self.move_history)[-seq_len:-1])
                next_move = self.move_history[-1]
                self.sequence_patterns[sequence][next_move] += 1
    
    def predict_next_move(self, method="combined"):
        """D·ª± ƒëo√°n n∆∞·ªõc ƒëi ti·∫øp theo"""
        if len(self.move_history) < 2:
            return random.choice(list(Move)), 0.33
        
        predictions = {}
        
        if method in ["frequency", "combined"]:
            predictions["frequency"] = self._frequency_prediction()
        
        if method in ["markov", "combined"]:
            predictions["markov"] = self._markov_prediction()
        
        if method in ["sequence", "combined"]:
            predictions["sequence"] = self._sequence_prediction()
        
        if method == "combined":
            return self._combine_predictions(predictions)
        else:
            pred_move, confidence = predictions.get(method, (random.choice(list(Move)), 0.33))
            return pred_move, confidence
    
    def _frequency_prediction(self):
        """D·ª± ƒëo√°n d·ª±a tr√™n t·∫ßn su·∫•t"""
        total_moves = sum(self.frequency_analysis.values())
        if total_moves == 0:
            return random.choice(list(Move)), 0.33
        
        # T√¨m move c√≥ t·∫ßn su·∫•t cao nh·∫•t
        most_frequent = max(self.frequency_analysis, key=self.frequency_analysis.get)
        confidence = self.frequency_analysis[most_frequent] / total_moves
        
        return most_frequent, confidence
    
    def _markov_prediction(self):
        """D·ª± ƒëo√°n d·ª±a tr√™n Markov chain"""
        if len(self.move_history) == 0:
            return random.choice(list(Move)), 0.33
        
        last_move = self.move_history[-1]
        transitions = self.markov_chain[last_move]
        
        if not transitions:
            return random.choice(list(Move)), 0.33
        
        total_transitions = sum(transitions.values())
        most_likely = max(transitions, key=transitions.get)
        confidence = transitions[most_likely] / total_transitions
        
        return most_likely, confidence
    
    def _sequence_prediction(self):
        """D·ª± ƒëo√°n d·ª±a tr√™n sequence patterns"""
        best_prediction = None
        best_confidence = 0
        
        # Th·ª≠ c√°c sequence lengths kh√°c nhau
        for seq_len in range(2, min(5, len(self.move_history) + 1)):
            if len(self.move_history) >= seq_len - 1:
                sequence = tuple(list(self.move_history)[-(seq_len-1):])
                
                if sequence in self.sequence_patterns:
                    patterns = self.sequence_patterns[sequence]
                    total_occurrences = sum(patterns.values())
                    
                    if total_occurrences > 0:
                        most_likely = max(patterns, key=patterns.get)
                        confidence = patterns[most_likely] / total_occurrences
                        
                        # ∆Øu ti√™n sequence d√†i h∆°n n·∫øu confidence t∆∞∆°ng ƒë∆∞∆°ng
                        if confidence > best_confidence or (
                            confidence == best_confidence and seq_len > len(sequence)
                        ):
                            best_prediction = most_likely
                            best_confidence = confidence
        
        if best_prediction:
            return best_prediction, best_confidence
        else:
            return random.choice(list(Move)), 0.33
    
    def _combine_predictions(self, predictions):
        """K·∫øt h·ª£p nhi·ªÅu ph∆∞∆°ng ph√°p d·ª± ƒëo√°n"""
        if not predictions:
            return random.choice(list(Move)), 0.33
        
        # Weighted combination
        weights = {
            "sequence": 0.4,    # ∆Øu ti√™n pattern sequences
            "markov": 0.35,     # Markov chain
            "frequency": 0.25   # Frequency analysis
        }
        
        combined_scores = defaultdict(float)
        total_weight = 0
        
        for method, (move, confidence) in predictions.items():
            if method in weights:
                weight = weights[method] * confidence
                combined_scores[move] += weight
                total_weight += weight
        
        if not combined_scores:
            return random.choice(list(Move)), 0.33
        
        # Normalize scores
        for move in combined_scores:
            combined_scores[move] /= total_weight
        
        best_move = max(combined_scores, key=combined_scores.get)
        best_confidence = combined_scores[best_move]
        
        return best_move, best_confidence
    
    def get_counter_move(self, predicted_move, confidence):
        """L·∫•y n∆∞·ªõc ƒëi counter l·∫°i d·ª± ƒëo√°n"""
        counter_moves = {
            Move.ROCK: Move.PAPER,
            Move.PAPER: Move.SCISSORS,
            Move.SCISSORS: Move.ROCK
        }
        
        # Th√™m m·ªôt ch√∫t randomness n·∫øu confidence th·∫•p
        if confidence < 0.6 and random.random() < 0.3:
            return random.choice(list(Move))
        
        return counter_moves[predicted_move]
```

### B∆∞·ªõc 3: AI Player Implementation

```python
class AIPlayer:
    """AI Player v·ªõi nhi·ªÅu m·ª©c ƒë·ªô th√¥ng minh kh√°c nhau"""
    
    def __init__(self, name, level=AILevel.INTERMEDIATE):
        self.name = name
        self.level = level
        self.stats = PlayerStats(name)
        self.pattern_analyzer = PatternAnalyzer()
        self.adaptation_counter = 0
        self.performance_history = deque(maxlen=20)
        
        # AI learning parameters
        self.learning_rate = 0.1
        self.exploration_rate = 0.2
        self.confidence_threshold = 0.7
    
    def make_move(self, opponent_history=None):
        """AI ƒë∆∞a ra quy·∫øt ƒë·ªãnh"""
        self.adaptation_counter += 1
        
        if self.level == AILevel.RANDOM:
            return self._random_move()
        elif self.level == AILevel.BASIC:
            return self._basic_pattern_move()
        elif self.level == AILevel.INTERMEDIATE:
            return self._frequency_analysis_move()
        elif self.level == AILevel.ADVANCED:
            return self._markov_chain_move()
        elif self.level == AILevel.EXPERT:
            return self._adaptive_learning_move()
        elif self.level == AILevel.MASTER:
            return self._deep_pattern_move()
        else:
            return self._random_move()
    
    def _random_move(self):
        """N∆∞·ªõc ƒëi ng·∫´u nhi√™n ho√†n to√†n"""
        return random.choice(list(Move))
    
    def _basic_pattern_move(self):
        """Ph√°t hi·ªán pattern ƒë∆°n gi·∫£n"""
        if len(self.pattern_analyzer.move_history) < 3:
            return random.choice(list(Move))
        
        # Ki·ªÉm tra pattern l·∫∑p l·∫°i ƒë∆°n gi·∫£n
        recent_moves = list(self.pattern_analyzer.move_history)[-3:]
        if recent_moves[0] == recent_moves[1] == recent_moves[2]:
            # ƒê·ªëi th·ªß c√≥ th·ªÉ s·∫Ω ti·∫øp t·ª•c pattern n√†y
            predicted = recent_moves[0]
            return self.pattern_analyzer.get_counter_move(predicted, 0.6)
        
        return random.choice(list(Move))
    
    def _frequency_analysis_move(self):
        """Ph√¢n t√≠ch t·∫ßn su·∫•t v√† counter"""
        predicted_move, confidence = self.pattern_analyzer.predict_next_move("frequency")
        
        if confidence > 0.4:
            return self.pattern_analyzer.get_counter_move(predicted_move, confidence)
        else:
            return random.choice(list(Move))
    
    def _markov_chain_move(self):
        """S·ª≠ d·ª•ng Markov chain ƒë·ªÉ d·ª± ƒëo√°n"""
        predicted_move, confidence = self.pattern_analyzer.predict_next_move("markov")
        
        # Th√™m m·ªôt ch√∫t exploration
        if random.random() < self.exploration_rate:
            return random.choice(list(Move))
        
        return self.pattern_analyzer.get_counter_move(predicted_move, confidence)
    
    def _adaptive_learning_move(self):
        """AI h·ªçc th√≠ch ·ª©ng t·ª´ performance"""
        predicted_move, confidence = self.pattern_analyzer.predict_next_move("combined")
        
        # ƒêi·ªÅu ch·ªânh strategy d·ª±a tr√™n performance g·∫ßn ƒë√¢y
        if len(self.performance_history) >= 5:
            recent_performance = sum(self.performance_history[-5:]) / 5
            
            if recent_performance < 0.4:  # ƒêang thua nhi·ªÅu
                # TƒÉng exploration v√† th·ª≠ ph∆∞∆°ng ph√°p kh√°c
                self.exploration_rate = min(0.4, self.exploration_rate + 0.05)
                if random.random() < 0.3:
                    return random.choice(list(Move))
            else:  # ƒêang th·∫Øng
                # Gi·∫£m exploration, tin t∆∞·ªüng v√†o prediction
                self.exploration_rate = max(0.1, self.exploration_rate - 0.02)
        
        if confidence > self.confidence_threshold:
            return self.pattern_analyzer.get_counter_move(predicted_move, confidence)
        else:
            # Exploration move
            if random.random() < self.exploration_rate:
                return random.choice(list(Move))
            return self.pattern_analyzer.get_counter_move(predicted_move, confidence)
    
    def _deep_pattern_move(self):
        """AI master v·ªõi deep pattern recognition"""
        # K·∫øt h·ª£p nhi·ªÅu ph∆∞∆°ng ph√°p v√† meta-learning
        predictions = {}
        
        # Multiple prediction methods
        for method in ["frequency", "markov", "sequence"]:
            move, conf = self.pattern_analyzer.predict_next_move(method)
            predictions[method] = (move, conf)
        
        # Meta-analysis: which method has been most accurate recently?
        method_weights = self._calculate_method_weights()
        
        # Weighted prediction
        final_prediction = self._weighted_prediction(predictions, method_weights)
        
        # Advanced counter-strategy
        return self._advanced_counter_strategy(final_prediction)
    
    def _calculate_method_weights(self):
        """T√≠nh tr·ªçng s·ªë cho c√°c ph∆∞∆°ng ph√°p d·ª± ƒëo√°n"""
        # Simplified version - trong th·ª±c t·∫ø s·∫Ω track accuracy c·ªßa t·ª´ng method
        return {
            "sequence": 0.4,
            "markov": 0.35,
            "frequency": 0.25
        }
    
    def _weighted_prediction(self, predictions, weights):
        """K·∫øt h·ª£p predictions v·ªõi tr·ªçng s·ªë"""
        move_scores = defaultdict(float)
        
        for method, (move, confidence) in predictions.items():
            weight = weights.get(method, 0.33)
            move_scores[move] += confidence * weight
        
        if move_scores:
            best_move = max(move_scores, key=move_scores.get)
            best_confidence = move_scores[best_move]
            return best_move, best_confidence
        else:
            return random.choice(list(Move)), 0.33
    
    def _advanced_counter_strategy(self, prediction):
        """Chi·∫øn thu·∫≠t counter n√¢ng cao"""
        predicted_move, confidence = prediction
        
        # Level 1: Direct counter
        if confidence > 0.8:
            return self.pattern_analyzer.get_counter_move(predicted_move, confidence)
        
        # Level 2: Meta-gaming (ƒë·ªëi th·ªß c√≥ th·ªÉ bi·∫øt m√¨nh s·∫Ω counter)
        elif confidence > 0.6:
            if random.random() < 0.3:  # 30% chance meta-game
                # Counter the counter
                counter_move = self.pattern_analyzer.get_counter_move(predicted_move, confidence)
                return self.pattern_analyzer.get_counter_move(counter_move, confidence)
            else:
                return self.pattern_analyzer.get_counter_move(predicted_move, confidence)
        
        # Level 3: Mixed strategy khi kh√¥ng ch·∫Øc ch·∫Øn
        else:
            return random.choice(list(Move))
    
    def update_opponent_move(self, opponent_move, result):
        """C·∫≠p nh·∫≠t th√¥ng tin v·ªÅ n∆∞·ªõc ƒëi c·ªßa ƒë·ªëi th·ªß"""
        self.pattern_analyzer.record_move(opponent_move)
        
        # Ghi l·∫°i performance ƒë·ªÉ adaptive learning
        performance_score = 1.0 if result == GameResult.WIN else (0.5 if result == GameResult.DRAW else 0.0)
        self.performance_history.append(performance_score)
        
        # Update stats
        my_move = None  # C·∫ßn track move c·ªßa AI
        self.stats.record_game(my_move, opponent_move, result)
    
    def get_strategy_info(self):
        """L·∫•y th√¥ng tin v·ªÅ chi·∫øn thu·∫≠t hi·ªán t·∫°i"""
        info = {
            "level": self.level.value,
            "exploration_rate": self.exploration_rate,
            "confidence_threshold": self.confidence_threshold,
            "games_analyzed": len(self.pattern_analyzer.move_history),
            "current_performance": sum(self.performance_history) / len(self.performance_history) if self.performance_history else 0
        }
        
        if len(self.pattern_analyzer.move_history) > 0:
            predicted_move, confidence = self.pattern_analyzer.predict_next_move()
            info["next_prediction"] = predicted_move.name
            info["prediction_confidence"] = confidence
        
        return info
```

### B∆∞·ªõc 4: Game Engine v√† Display

```python
class GameDisplay:
    """Class x·ª≠ l√Ω hi·ªÉn th·ªã game"""
    
    @staticmethod
    def clear_screen():
        """X√≥a m√†n h√¨nh"""
        import os
        os.system('cls' if os.name == 'nt' else 'clear')
    
    @staticmethod
    def display_title():
        """Hi·ªÉn th·ªã title"""
        print("üéÆ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ROCK-PAPER-SCISSORS CHAMPIONSHIP ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê üéÆ")
        print()
    
    @staticmethod
    def display_round_result(player_move, ai_move, result, round_num):
        """Hi·ªÉn th·ªã k·∫øt qu·∫£ round"""
        print(f"\nüéØ Round {round_num}")
        print("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
        print("‚îÇ     YOU         ‚îÇ    OPPONENT     ‚îÇ")
        print(f"‚îÇ      {player_move}         ‚îÇ       {ai_move}        ‚îÇ")
        print(f"‚îÇ   ({player_move.name.title()})    ‚îÇ     ({ai_move.name.title()})      ‚îÇ")
        
        if result == GameResult.WIN:
            print("‚îÇ    üèÜ WINS!     ‚îÇ                 ‚îÇ")
        elif result == GameResult.LOSE:
            print("‚îÇ                 ‚îÇ    üèÜ WINS!     ‚îÇ")
        else:
            print("‚îÇ    ü§ù DRAW      ‚îÇ    ü§ù DRAW      ‚îÇ")
        
        print("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")
    
    @staticmethod
    def display_stats(stats, ai_stats=None):
        """Hi·ªÉn th·ªã th·ªëng k√™"""
        print(f"\nüìä Your Stats:")
        print(f"   Games: {stats.total_games} | W: {stats.wins} | L: {stats.losses} | D: {stats.draws}")
        print(f"   Win Rate: {stats.get_win_rate():.1f}% | Streak: {stats.current_streak}")
        
        distribution = stats.get_move_distribution()
        print(f"   Moves: üóø{distribution[Move.ROCK]:.0f}% üìÑ{distribution[Move.PAPER]:.0f}% ‚úÇÔ∏è{distribution[Move.SCISSORS]:.0f}%")
        
        if ai_stats:
            print(f"\nü§ñ AI Stats:")
            print(f"   Games: {ai_stats.total_games} | W: {ai_stats.wins} | Win Rate: {ai_stats.get_win_rate():.1f}%")
    
    @staticmethod
    def display_pattern_analysis(analyzer):
        """Hi·ªÉn th·ªã ph√¢n t√≠ch pattern"""
        if len(analyzer.move_history) < 3:
            return
        
        print(f"\nüìà Pattern Analysis:")
        
        # Recent moves
        recent = list(analyzer.move_history)[-10:]
        recent_str = " ‚Üí ".join([move.value for move in recent])
        print(f"   Recent: {recent_str}")
        
        # Frequency analysis
        total = sum(analyzer.frequency_analysis.values())
        if total > 0:
            freq_str = " | ".join([
                f"{move.value}({count/total*100:.0f}%)" 
                for move, count in analyzer.frequency_analysis.items()
            ])
            print(f"   Frequency: {freq_str}")
        
        # Prediction
        predicted_move, confidence = analyzer.predict_next_move()
        print(f"   AI Prediction: {predicted_move.value} (Confidence: {confidence*100:.0f}%)")
    
    @staticmethod
    def display_menu():
        """Hi·ªÉn th·ªã menu ch√≠nh"""
        print("\nüéÆ Main Menu:")
        print("1. üéØ Classic Game")
        print("2. üèÜ Tournament Mode") 
        print("3. ü§ñ AI Training")
        print("4. üìä View Statistics")
        print("5. ‚öôÔ∏è Settings")
        print("6. üö™ Exit")
    
    @staticmethod
    def display_game_menu():
        """Hi·ªÉn th·ªã menu trong game"""
        print("\nüìã Your move:")
        print("1. üóø Rock")
        print("2. üìÑ Paper")
        print("3. ‚úÇÔ∏è Scissors")
        print("4. üìä View Stats")
        print("5. üéØ Strategy Hint")
        print("6. üîÑ Change AI Level")
        print("7. üèÉ Quit to Menu")

class RockPaperScissorsGame:
    """Game engine ch√≠nh"""
    
    def __init__(self):
        self.player_stats = PlayerStats("Player")
        self.ai_player = AIPlayer("SmartAI", AILevel.INTERMEDIATE)
        self.current_round = 0
        self.session_stats = {
            'start_time': datetime.now(),
            'games_played': 0,
            'different_ais_faced': set()
        }
        self.display = GameDisplay()
    
    def start(self):
        """B·∫Øt ƒë·∫ßu game"""
        self.display.clear_screen()
        self.display.display_title()
        
        print("üåü Welcome to Rock-Paper-Scissors Championship!")
        print("   Advanced AI ‚Ä¢ Pattern Analysis ‚Ä¢ Tournament Mode")
        
        while True:
            self.display.display_menu()
            choice = input("\nChoose an option: ").strip()
            
            if choice == '1':
                self.play_classic_game()
            elif choice == '2':
                self.tournament_mode()
            elif choice == '3':
                self.ai_training_mode()
            elif choice == '4':
                self.view_statistics()
            elif choice == '5':
                self.settings_menu()
            elif choice == '6':
                print("üëã Thanks for playing! See you next time!")
                break
            else:
                print("‚ùå Invalid choice! Please try again.")
                time.sleep(1)
    
    def play_classic_game(self):
        """Ch∆°i game classic v·ªõi AI"""
        self.display.clear_screen()
        print("üéØ Classic Game Mode")
        print(f"ü§ñ Current AI: {self.ai_player.name} ({self.ai_player.level.value})")
        
        rounds_to_play = self.get_rounds_input()
        if rounds_to_play is None:
            return
        
        round_count = 0
        
        while round_count < rounds_to_play:
            self.display.clear_screen()
            self.display.display_title()
            print(f"üéØ Round {round_count + 1}/{rounds_to_play}")
            
            # Hi·ªÉn th·ªã stats v√† pattern analysis
            if round_count > 0:
                self.display.display_stats(self.player_stats, self.ai_player.stats)
                self.display.display_pattern_analysis(self.ai_player.pattern_analyzer)
            
            self.display.display_game_menu()
            choice = input("\nYour choice: ").strip()
            
            if choice in ['1', '2', '3']:
                moves = {
                    '1': Move.ROCK,
                    '2': Move.PAPER, 
                    '3': Move.SCISSORS
                }
                player_move = moves[choice]
                
                # AI makes move
                ai_move = self.ai_player.make_move()
                
                # Determine result
                result = self.determine_result(player_move, ai_move)
                
                # Update stats
                self.update_game_stats(player_move, ai_move, result)
                
                # Display result
                self.display.display_round_result(player_move, ai_move, result, round_count + 1)
                
                round_count += 1
                
                if round_count < rounds_to_play:
                    input("\nPress Enter to continue...")
                
            elif choice == '4':
                self.show_detailed_stats()
            elif choice == '5':
                self.show_strategy_hint()
            elif choice == '6':
                self.change_ai_level()
            elif choice == '7':
                break
            else:
                print("‚ùå Invalid choice!")
                time.sleep(1)
        
        # Show final results
        if round_count > 0:
            self.show_game_summary(rounds_to_play)
    
    def determine_result(self, player_move, ai_move):
        """X√°c ƒë·ªãnh k·∫øt qu·∫£ game"""
        if player_move == ai_move:
            return GameResult.DRAW
        elif player_move.beats(ai_move):
            return GameResult.WIN
        else:
            return GameResult.LOSE
    
    def update_game_stats(self, player_move, ai_move, result):
        """C·∫≠p nh·∫≠t th·ªëng k√™"""
        self.player_stats.record_game(player_move, ai_move, result)
        
        # Update AI
        ai_result = GameResult.LOSE if result == GameResult.WIN else (
            GameResult.WIN if result == GameResult.LOSE else GameResult.DRAW
        )
        self.ai_player.update_opponent_move(player_move, ai_result)
        self.ai_player.stats.record_game(ai_move, player_move, ai_result)
        
        self.session_stats['games_played'] += 1
        self.session_stats['different_ais_faced'].add(self.ai_player.name)
    
    def get_rounds_input(self):
        """L·∫•y s·ªë rounds mu·ªën ch∆°i"""
        while True:
            try:
                rounds = input("How many rounds? (1-100, or 'back' to return): ").strip()
                if rounds.lower() == 'back':
                    return None
                rounds = int(rounds)
                if 1 <= rounds <= 100:
                    return rounds
                else:
                    print("‚ùå Please enter a number between 1 and 100!")
            except ValueError:
                print("‚ùå Please enter a valid number!")
    
    def show_detailed_stats(self):
        """Hi·ªÉn th·ªã th·ªëng k√™ chi ti·∫øt"""
        self.display.clear_screen()
        print("üìä ‚ïê‚ïê‚ïê DETAILED STATISTICS ‚ïê‚ïê‚ïê")
        
        # Player stats
        print(f"\nüë§ Player Stats:")
        print(f"   Total Games: {self.player_stats.total_games}")
        print(f"   Wins: {self.player_stats.wins} ({self.player_stats.get_win_rate():.1f}%)")
        print(f"   Losses: {self.player_stats.losses}")
        print(f"   Draws: {self.player_stats.draws}")
        print(f"   Current Streak: {self.player_stats.current_streak}")
        print(f"   Longest Streak: {self.player_stats.longest_streak}")
        
        # Move distribution
        dist = self.player_stats.get_move_distribution()
        print(f"\nüéØ Move Distribution:")
        for move, percentage in dist.items():
            print(f"   {move.value} {move.name}: {percentage:.1f}%")
        
        # AI stats  
        print(f"\nü§ñ AI Stats:")
        ai_info = self.ai_player.get_strategy_info()
        for key, value in ai_info.items():
            print(f"   {key.replace('_', ' ').title()}: {value}")
        
        input("\nPress Enter to continue...")
    
    def show_strategy_hint(self):
        """Hi·ªÉn th·ªã g·ª£i √Ω chi·∫øn thu·∫≠t"""
        if len(self.ai_player.pattern_analyzer.move_history) < 3:
            print("\nüí° Not enough data for analysis yet. Play more rounds!")
        else:
            predicted_move, confidence = self.ai_player.pattern_analyzer.predict_next_move()
            counter_move = self.ai_player.pattern_analyzer.get_counter_move(predicted_move, confidence)
            
            print(f"\nüí° Strategy Hint:")
            print(f"   AI predicts you'll play: {predicted_move.value} ({confidence*100:.0f}% confidence)")
            print(f"   Suggested counter: {counter_move.value}")
            
            # Additional advice
            if confidence > 0.7:
                print(f"   üí™ High confidence prediction - consider the counter!")
            elif confidence > 0.5:
                print(f"   ü§î Medium confidence - mix up your strategy")
            else:
                print(f"   üé≤ Low confidence - your pattern is unpredictable!")
        
        input("\nPress Enter to continue...")
    
    def change_ai_level(self):
        """Thay ƒë·ªïi m·ª©c ƒë·ªô AI"""
        print("\nüîß Choose AI Level:")
        levels = list(AILevel)
        for i, level in enumerate(levels, 1):
            current = " (Current)" if level == self.ai_player.level else ""
            print(f"   {i}. {level.value}{current}")
        
        try:
            choice = int(input("\nSelect level (1-6): ")) - 1
            if 0 <= choice < len(levels):
                old_level = self.ai_player.level
                self.ai_player.level = levels[choice]
                print(f"‚úÖ AI level changed from {old_level.value} to {levels[choice].value}")
            else:
                print("‚ùå Invalid choice!")
        except ValueError:
            print("‚ùå Please enter a number!")
        
        time.sleep(2)
    
    def show_game_summary(self, total_rounds):
        """Hi·ªÉn th·ªã t·ªïng k·∫øt game"""
        self.display.clear_screen()
        print("üèÅ ‚ïê‚ïê‚ïê GAME SUMMARY ‚ïê‚ïê‚ïê")
        
        print(f"\nüìä Results after {total_rounds} rounds:")
        print(f"   Your wins: {self.player_stats.wins}")
        print(f"   AI wins: {self.ai_player.stats.wins}")
        print(f"   Draws: {self.player_stats.draws}")
        
        if self.player_stats.wins > self.ai_player.stats.wins:
            print("\nüéâ Congratulations! You won the match!")
        elif self.player_stats.wins < self.ai_player.stats.wins:
            print("\nü§ñ AI wins this match! Better luck next time!")
        else:
            print("\nü§ù It's a tie! Great match!")
        
        print(f"\nüìà Your final win rate: {self.player_stats.get_win_rate():.1f}%")
        
        input("\nPress Enter to return to menu...")
    
    def tournament_mode(self):
        """Ch·∫ø ƒë·ªô tournament (simplified for now)"""
        print("\nüèÜ Tournament Mode - Coming Soon!")
        print("   Features in development:")
        print("   ‚Ä¢ Round Robin tournaments")
        print("   ‚Ä¢ Elimination brackets") 
        print("   ‚Ä¢ Multiple AI opponents")
        print("   ‚Ä¢ Leaderboards")
        
        input("\nPress Enter to return to menu...")
    
    def ai_training_mode(self):
        """Ch·∫ø ƒë·ªô training AI"""
        print("\nü§ñ AI Training Mode - Coming Soon!")
        print("   Features in development:")
        print("   ‚Ä¢ Train AI with your playing style")
        print("   ‚Ä¢ Export/Import AI models")
        print("   ‚Ä¢ Create custom AI opponents")
        
        input("\nPress Enter to return to menu...")
    
    def view_statistics(self):
        """Xem th·ªëng k√™ t·ªïng qu√°t"""
        self.show_detailed_stats()
    
    def settings_menu(self):
        """Menu c√†i ƒë·∫∑t"""
        print("\n‚öôÔ∏è Settings - Coming Soon!")
        print("   ‚Ä¢ Save/Load game data")
        print("   ‚Ä¢ Customize display")
        print("   ‚Ä¢ Export statistics")
        
        input("\nPress Enter to return to menu...")

if __name__ == "__main__":
    game = RockPaperScissorsGame()
    game.start()
```

## Ph·∫ßn 3: Tournament System (Preview)

### Tournament Manager

```python
class TournamentManager:
    """Qu·∫£n l√Ω h·ªá th·ªëng tournament"""
    
    def __init__(self):
        self.participants = []
        self.tournament_type = None
        self.results = []
        
    def create_round_robin(self, participants):
        """T·∫°o tournament round robin"""
        matches = []
        for i in range(len(participants)):
            for j in range(i + 1, len(participants)):
                matches.append((participants[i], participants[j]))
        return matches
    
    def create_elimination(self, participants):
        """T·∫°o tournament elimination"""
        # Implementation for elimination brackets
        pass
    
    def run_tournament(self):
        """Ch·∫°y tournament"""
        # Implementation for running matches
        pass
```

## Ph·∫ßn 4: Advanced Features (Preview)

### Machine Learning Integration

```python
import numpy as np
from sklearn.naive_bayes import MultinomialNB

class MLPredictor:
    """Machine Learning predictor cho n√¢ng cao h∆°n"""
    
    def __init__(self):
        self.model = MultinomialNB()
        self.is_trained = False
        self.feature_history = []
        self.target_history = []
    
    def extract_features(self, move_history):
        """Tr√≠ch xu·∫•t features t·ª´ l·ªãch s·ª≠ moves"""
        # Convert moves to numerical features
        # Implementation t√πy thu·ªôc v√†o strategy
        pass
    
    def train(self, training_data):
        """Train model v·ªõi d·ªØ li·ªáu"""
        # Implementation for ML training
        pass
    
    def predict(self, current_features):
        """D·ª± ƒëo√°n move ti·∫øp theo"""
        # Implementation for prediction
        pass
```

## Th·ª≠ Th√°ch Cho B·∫°n

H√£y m·ªü r·ªông game v·ªõi nh·ªØng t√≠nh nƒÉng n√†y:

- [ ] **Tournament System**: Ho√†n thi·ªán round robin v√† elimination brackets
- [ ] **Machine Learning**: T√≠ch h·ª£p scikit-learn cho prediction n√¢ng cao
- [ ] **Multiplayer Online**: Ch∆°i qua m·∫°ng v·ªõi socket programming
- [ ] **GUI Version**: T·∫°o giao di·ªán ƒë·ªì h·ªça v·ªõi Tkinter/Pygame
- [ ] **Statistics Dashboard**: Bi·ªÉu ƒë·ªì v√† visualization v·ªõi matplotlib
- [ ] **AI Personality**: T·∫°o AI v·ªõi c√°c "t√≠nh c√°ch" ch∆°i kh√°c nhau
- [ ] **Voice Control**: ƒêi·ªÅu khi·ªÉn b·∫±ng gi·ªçng n√≥i
- [ ] **Mobile App**: Port sang Android/iOS

## Source Code v√† Resources

:::tip T√†i Nguy√™n H·ªçc T·∫≠p
**GitHub Repository**: [rps-championship-python](https://github.com/behitek/rps-championship-python)  
**Documentation**: H∆∞·ªõng d·∫´n chi ti·∫øt t·ª´ng component  
**Video Series**: Playlist gi·∫£i th√≠ch c√°c algorithms  
:::

## B√†i Ti·∫øp Theo

Trong b√†i ti·∫øp theo, ch√∫ng ta s·∫Ω h·ªçc c√°ch **"T·∫°o Text Adventure Game"** - x√¢y d·ª±ng th·∫ø gi·ªõi game RPG v·ªõi story branching, inventory system v√† quest management!

:::note K·∫øt Lu·∫≠n
Rock-Paper-Scissors t∆∞·ªüng ƒë∆°n gi·∫£n nh∆∞ng ƒë√£ d·∫°y ch√∫ng ta r·∫•t nhi·ªÅu v·ªÅ AI, pattern recognition, v√† system design. T·ª´ game c∆° b·∫£n, ch√∫ng ta ƒë√£ x√¢y d·ª±ng m·ªôt h·ªá th·ªëng ho√†n ch·ªânh v·ªõi nhi·ªÅu t√≠nh nƒÉng n√¢ng cao. ƒê√¢y l√† b∆∞·ªõc ƒë·ªám tuy·ªát v·ªùi cho vi·ªác ph√°t tri·ªÉn AI game ph·ª©c t·∫°p h∆°n!
:::

Ch√∫c b·∫°n coding vui v·∫ª v√† chi·∫øn th·∫Øng m·ªçi AI! üöÄü§ñ