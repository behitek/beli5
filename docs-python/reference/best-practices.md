# üèÜ Th·ª±c H√†nh T·ªët Nh·∫•t Python - Best Practices

> **T√≥m t·∫Øt**: T·ªïng h·ª£p c√°c th·ª±c h√†nh t·ªët nh·∫•t, m·∫πo hay v√† kinh nghi·ªám t·ª´ c·ªông ƒë·ªìng Python ƒë·ªÉ vi·∫øt code ch·∫•t l∆∞·ª£ng cao, maintainable v√† professional.

## üéØ T·∫°i Sao C·∫ßn Best Practices?

Th·ª≠ t∆∞·ªüng t∆∞·ª£ng b·∫°n l√† m·ªôt th·∫ßy thu·ªëc üë®‚Äç‚öïÔ∏è. C√≥ th·ªÉ b·∫°n bi·∫øt c√°ch ch·ªØa b·ªánh, nh∆∞ng n·∫øu kh√¥ng tu√¢n theo quy tr√¨nh chu·∫©n (r·ª≠a tay, kh·ª≠ tr√πng, ki·ªÉm tra k·ªπ...), b·∫°n c√≥ th·ªÉ g√¢y h·∫°i cho b·ªánh nh√¢n!

L·∫≠p tr√¨nh c≈©ng v·∫≠y! Best practices nh∆∞ "quy tr√¨nh chu·∫©n" gi√∫p code c·ªßa b·∫°n an to√†n, d·ªÖ maintain v√† √≠t bug. ƒê√¢y l√† kinh nghi·ªám ƒë∆∞·ª£c t√≠ch l≈©y t·ª´ h√†ng tri·ªáu l·∫≠p tr√¨nh vi√™n tr√™n th·∫ø gi·ªõi!

---

## üé® 1. CLEAN CODE PRINCIPLES

### Single Responsibility Principle (SRP)
```python
# ‚ùå Function l√†m qu√° nhi·ªÅu vi·ªác
def process_student_data(data):
    # Validate data
    if not data or not isinstance(data, dict):
        raise ValueError("Invalid data")
    
    # Parse name
    full_name = data.get('name', '').strip()
    if not full_name:
        raise ValueError("Name is required")
    
    # Calculate grade
    scores = data.get('scores', [])
    average = sum(scores) / len(scores) if scores else 0
    
    # Determine status
    status = 'PASS' if average >= 5.0 else 'FAIL'
    
    # Format output
    result = f"{full_name}: {average:.2f} ({status})"
    
    # Log result
    print(f"Processed: {result}")
    
    # Save to file
    with open('results.txt', 'a') as f:
        f.write(result + '\n')
    
    return result

# ‚úÖ Chia nh·ªè th√†nh c√°c functions ri√™ng bi·ªát
def validate_student_data(data):
    """Validate d·ªØ li·ªáu h·ªçc sinh."""
    if not data or not isinstance(data, dict):
        raise ValueError("Invalid data format")
    
    if not data.get('name', '').strip():
        raise ValueError("Name is required")
    
    return True

def calculate_average_score(scores):
    """T√≠nh ƒëi·ªÉm trung b√¨nh."""
    if not scores:
        return 0.0
    return sum(scores) / len(scores)

def determine_pass_status(average, passing_grade=5.0):
    """X√°c ƒë·ªãnh tr·∫°ng th√°i ƒë·∫≠u/r·ªõt."""
    return 'PASS' if average >= passing_grade else 'FAIL'

def format_student_result(name, average, status):
    """Format k·∫øt qu·∫£ h·ªçc sinh."""
    return f"{name.strip()}: {average:.2f} ({status})"

def log_result(message):
    """Ghi log k·∫øt qu·∫£."""
    print(f"Processed: {message}")

def save_result_to_file(result, filename='results.txt'):
    """L∆∞u k·∫øt qu·∫£ v√†o file."""
    with open(filename, 'a', encoding='utf-8') as f:
        f.write(result + '\n')

def process_student_data(data):
    """X·ª≠ l√Ω d·ªØ li·ªáu h·ªçc sinh - orchestrator function."""
    validate_student_data(data)
    
    name = data['name']
    scores = data.get('scores', [])
    
    average = calculate_average_score(scores)
    status = determine_pass_status(average)
    result = format_student_result(name, average, status)
    
    log_result(result)
    save_result_to_file(result)
    
    return result
```

### DRY Principle (Don't Repeat Yourself)
```python
# ‚ùå Code l·∫∑p l·∫°i
def calculate_math_grade(scores):
    if not scores:
        return 0
    total = sum(scores)
    count = len(scores)
    average = total / count
    if average >= 8.5:
        return 'A'
    elif average >= 7.0:
        return 'B'
    elif average >= 5.5:
        return 'C'
    else:
        return 'F'

def calculate_science_grade(scores):
    if not scores:
        return 0
    total = sum(scores)
    count = len(scores)
    average = total / count
    if average >= 8.5:
        return 'A'
    elif average >= 7.0:
        return 'B'
    elif average >= 5.5:
        return 'C'
    else:
        return 'F'

# ‚úÖ T√°i s·ª≠ d·ª•ng code
def calculate_average(scores):
    """T√≠nh ƒëi·ªÉm trung b√¨nh."""
    if not scores:
        return 0.0
    return sum(scores) / len(scores)

def get_letter_grade(average):
    """Chuy·ªÉn ƒë·ªïi ƒëi·ªÉm s·ªë th√†nh ƒëi·ªÉm ch·ªØ."""
    grade_scale = [
        (8.5, 'A'),
        (7.0, 'B'), 
        (5.5, 'C'),
        (0.0, 'F')
    ]
    
    for min_score, letter in grade_scale:
        if average >= min_score:
            return letter
    return 'F'

def calculate_subject_grade(scores):
    """T√≠nh ƒëi·ªÉm m√¥n h·ªçc."""
    average = calculate_average(scores)
    return get_letter_grade(average)

# S·ª≠ d·ª•ng
math_grade = calculate_subject_grade(math_scores)
science_grade = calculate_subject_grade(science_scores)
english_grade = calculate_subject_grade(english_scores)
```

### KISS Principle (Keep It Simple, Stupid)
```python
# ‚ùå Qu√° ph·ª©c t·∫°p
def is_passing_grade(scores, weights=None, curve=None, extra_credit=None):
    if weights is None:
        weights = [1.0] * len(scores)
    
    if curve is None:
        curve = lambda x: x
    
    if extra_credit is None:
        extra_credit = 0
    
    weighted_scores = []
    for i, score in enumerate(scores):
        weight = weights[i] if i < len(weights) else 1.0
        curved_score = curve(score)
        weighted_score = curved_score * weight
        weighted_scores.append(weighted_score)
    
    total_weight = sum(weights)
    weighted_average = sum(weighted_scores) / total_weight
    final_score = weighted_average + extra_credit
    
    return final_score >= 5.0

# ‚úÖ ƒê∆°n gi·∫£n v√† r√µ r√†ng
def is_passing_grade(scores, passing_threshold=5.0):
    """Ki·ªÉm tra c√≥ ƒë·∫≠u kh√¥ng (ƒë∆°n gi·∫£n)."""
    if not scores:
        return False
    
    average = sum(scores) / len(scores)
    return average >= passing_threshold

# N·∫øu c·∫ßn t√≠nh nƒÉng ph·ª©c t·∫°p, t√°ch ri√™ng
class GradeCalculator:
    """Calculator cho c√°c ph√©p t√≠nh ƒëi·ªÉm ph·ª©c t·∫°p."""
    
    def __init__(self, passing_threshold=5.0):
        self.passing_threshold = passing_threshold
    
    def calculate_weighted_average(self, scores, weights):
        """T√≠nh trung b√¨nh c√≥ tr·ªçng s·ªë."""
        if len(scores) != len(weights):
            raise ValueError("Scores and weights must have same length")
        
        weighted_sum = sum(score * weight for score, weight in zip(scores, weights))
        total_weight = sum(weights)
        
        return weighted_sum / total_weight if total_weight > 0 else 0
    
    def apply_curve(self, score, curve_function):
        """√Åp d·ª•ng curve cho ƒëi·ªÉm."""
        return curve_function(score)
    
    def is_passing(self, final_score):
        """Ki·ªÉm tra ƒë·∫≠u/r·ªõt."""
        return final_score >= self.passing_threshold
```

---

## üõ°Ô∏è 2. DEFENSIVE PROGRAMMING

### Input Validation
```python
def create_student(name, age, email, student_id):
    """
    T·∫°o h·ªçc sinh m·ªõi v·ªõi validation ƒë·∫ßy ƒë·ªß.
    
    Args:
        name (str): T√™n h·ªçc sinh
        age (int): Tu·ªïi
        email (str): Email
        student_id (str): M√£ s·ªë h·ªçc sinh
    
    Returns:
        Student: ƒê·ªëi t∆∞·ª£ng h·ªçc sinh
    
    Raises:
        ValueError: Khi d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá
        TypeError: Khi ki·ªÉu d·ªØ li·ªáu sai
    """
    # Type validation
    if not isinstance(name, str):
        raise TypeError(f"Name must be string, got {type(name).__name__}")
    
    if not isinstance(age, int):
        raise TypeError(f"Age must be integer, got {type(age).__name__}")
    
    if not isinstance(email, str):
        raise TypeError(f"Email must be string, got {type(email).__name__}")
    
    if not isinstance(student_id, str):
        raise TypeError(f"Student ID must be string, got {type(student_id).__name__}")
    
    # Value validation
    name = name.strip()
    if not name:
        raise ValueError("Name cannot be empty")
    
    if len(name) > 100:
        raise ValueError("Name too long (max 100 characters)")
    
    if not 16 <= age <= 100:
        raise ValueError("Age must be between 16 and 100")
    
    # Email validation
    import re
    email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_pattern, email):
        raise ValueError("Invalid email format")
    
    # Student ID validation
    student_id = student_id.strip().upper()
    if not student_id:
        raise ValueError("Student ID cannot be empty")
    
    if not re.match(r'^[A-Z0-9]{6,10}$', student_id):
        raise ValueError("Student ID must be 6-10 alphanumeric characters")
    
    return Student(name, age, email, student_id)

# Helper function cho validation
def validate_grade(grade, subject=""):
    """Validate ƒëi·ªÉm s·ªë."""
    if not isinstance(grade, (int, float)):
        raise TypeError(f"Grade must be number, got {type(grade).__name__}")
    
    if not 0 <= grade <= 10:
        subject_info = f" for {subject}" if subject else ""
        raise ValueError(f"Grade{subject_info} must be between 0 and 10, got {grade}")
    
    return float(grade)
```

### Safe Operations
```python
def safe_divide(dividend, divisor, default=0):
    """Chia an to√†n, tr√°nh ZeroDivisionError."""
    try:
        if divisor == 0:
            return default
        return dividend / divisor
    except (TypeError, ValueError):
        return default

def safe_get_item(collection, key, default=None):
    """L·∫•y item an to√†n t·ª´ collection."""
    try:
        if isinstance(collection, dict):
            return collection.get(key, default)
        elif isinstance(collection, (list, tuple)):
            if isinstance(key, int) and 0 <= key < len(collection):
                return collection[key]
            return default
        else:
            return getattr(collection, key, default)
    except (KeyError, IndexError, AttributeError, TypeError):
        return default

def safe_int_conversion(value, default=0):
    """Chuy·ªÉn ƒë·ªïi th√†nh int an to√†n."""
    try:
        return int(value)
    except (ValueError, TypeError):
        return default

# V√≠ d·ª• s·ª≠ d·ª•ng
student_data = {"name": "An", "scores": [8, 9, "invalid", 7]}

# Safe processing
processed_scores = []
for score in student_data["scores"]:
    safe_score = safe_int_conversion(score)
    if safe_score > 0:  # Ch·ªâ l·∫•y ƒëi·ªÉm h·ª£p l·ªá
        processed_scores.append(safe_score)

average = safe_divide(sum(processed_scores), len(processed_scores))
print(f"Average: {average}")
```

### Error Recovery
```python
import logging
from typing import Optional, Any

class DataProcessor:
    """X·ª≠ l√Ω d·ªØ li·ªáu v·ªõi error recovery."""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.failed_items = []
    
    def process_student_list(self, students_data):
        """X·ª≠ l√Ω danh s√°ch h·ªçc sinh v·ªõi error recovery."""
        processed_students = []
        
        for i, student_data in enumerate(students_data):
            try:
                student = self.process_single_student(student_data)
                if student:
                    processed_students.append(student)
            except Exception as e:
                self.logger.error(f"Failed to process student {i}: {e}")
                self.failed_items.append((i, student_data, str(e)))
                continue  # Ti·∫øp t·ª•c v·ªõi student ti·∫øp theo
        
        # Report summary
        total = len(students_data)
        success = len(processed_students)
        failed = len(self.failed_items)
        
        self.logger.info(f"Processed {success}/{total} students successfully")
        if failed > 0:
            self.logger.warning(f"{failed} students failed to process")
        
        return processed_students
    
    def process_single_student(self, data):
        """X·ª≠ l√Ω m·ªôt h·ªçc sinh v·ªõi fallback values."""
        try:
            # Primary processing
            return self.create_student_from_data(data)
        except ValueError as e:
            # Try to recover with default values
            self.logger.warning(f"Using default values for student: {e}")
            return self.create_student_with_defaults(data)
    
    def create_student_with_defaults(self, data):
        """T·∫°o student v·ªõi gi√° tr·ªã m·∫∑c ƒë·ªãnh."""
        name = data.get('name', 'Unknown Student')
        age = safe_int_conversion(data.get('age'), 18)
        email = data.get('email', 'no-email@example.com')
        student_id = data.get('id', f"TEMP_{hash(name) % 10000:04d}")
        
        return {
            'name': name,
            'age': age,
            'email': email,
            'student_id': student_id,
            'status': 'incomplete_data'
        }
    
    def get_failed_items(self):
        """L·∫•y danh s√°ch items failed ƒë·ªÉ review."""
        return self.failed_items
```

---

## üé≠ 3. DESIGN PATTERNS

### Factory Pattern
```python
from abc import ABC, abstractmethod
from enum import Enum

class StudentType(Enum):
    REGULAR = "regular"
    INTERNATIONAL = "international"
    EXCHANGE = "exchange"

class Student(ABC):
    """Base class cho t·∫•t c·∫£ lo·∫°i h·ªçc sinh."""
    
    def __init__(self, name, student_id):
        self.name = name
        self.student_id = student_id
    
    @abstractmethod
    def calculate_tuition(self):
        """T√≠nh h·ªçc ph√≠."""
        pass
    
    @abstractmethod
    def get_graduation_requirements(self):
        """L·∫•y y√™u c·∫ßu t·ªët nghi·ªáp."""
        pass

class RegularStudent(Student):
    """H·ªçc sinh th∆∞·ªùng."""
    
    def calculate_tuition(self):
        return 5000000  # 5 tri·ªáu VND
    
    def get_graduation_requirements(self):
        return {
            'min_credits': 120,
            'min_gpa': 2.0,
            'thesis_required': True
        }

class InternationalStudent(Student):
    """H·ªçc sinh qu·ªëc t·∫ø."""
    
    def __init__(self, name, student_id, country):
        super().__init__(name, student_id)
        self.country = country
    
    def calculate_tuition(self):
        return 15000000  # 15 tri·ªáu VND
    
    def get_graduation_requirements(self):
        return {
            'min_credits': 120,
            'min_gpa': 2.5,
            'thesis_required': True,
            'language_test': True
        }

class ExchangeStudent(Student):
    """H·ªçc sinh trao ƒë·ªïi."""
    
    def __init__(self, name, student_id, home_university, duration):
        super().__init__(name, student_id)
        self.home_university = home_university
        self.duration = duration
    
    def calculate_tuition(self):
        return 0  # Mi·ªÖn h·ªçc ph√≠
    
    def get_graduation_requirements(self):
        return {
            'min_credits': 30,
            'min_gpa': 2.0,
            'thesis_required': False
        }

class StudentFactory:
    """Factory ƒë·ªÉ t·∫°o c√°c lo·∫°i h·ªçc sinh."""
    
    @staticmethod
    def create_student(student_type: StudentType, **kwargs):
        """
        T·∫°o h·ªçc sinh theo type.
        
        Args:
            student_type: Lo·∫°i h·ªçc sinh
            **kwargs: C√°c tham s·ªë c·∫ßn thi·∫øt
        
        Returns:
            Student: Instance c·ªßa h·ªçc sinh
        """
        if student_type == StudentType.REGULAR:
            return RegularStudent(
                kwargs['name'],
                kwargs['student_id']
            )
        elif student_type == StudentType.INTERNATIONAL:
            return InternationalStudent(
                kwargs['name'],
                kwargs['student_id'],
                kwargs['country']
            )
        elif student_type == StudentType.EXCHANGE:
            return ExchangeStudent(
                kwargs['name'],
                kwargs['student_id'],
                kwargs['home_university'],
                kwargs['duration']
            )
        else:
            raise ValueError(f"Unknown student type: {student_type}")

# S·ª≠ d·ª•ng Factory
regular_student = StudentFactory.create_student(
    StudentType.REGULAR,
    name="Nguy·ªÖn VƒÉn An",
    student_id="SV001"
)

international_student = StudentFactory.create_student(
    StudentType.INTERNATIONAL,
    name="John Smith",
    student_id="IS001",
    country="USA"
)
```

### Observer Pattern
```python
from typing import List, Protocol

class Observer(Protocol):
    """Interface cho Observer."""
    
    def update(self, student, event_type, data):
        """ƒê∆∞·ª£c g·ªçi khi c√≥ s·ª± ki·ªán."""
        pass

class GradeNotificationService:
    """Service g·ª≠i th√¥ng b√°o ƒëi·ªÉm."""
    
    def update(self, student, event_type, data):
        if event_type == 'grade_added':
            subject = data['subject']
            grade = data['grade']
            print(f"üìß G·ª≠i email: {student.name} c√≥ ƒëi·ªÉm {grade} m√¥n {subject}")
        elif event_type == 'grade_updated':
            subject = data['subject']
            old_grade = data['old_grade']
            new_grade = data['new_grade']
            print(f"üìß ƒêi·ªÉm {subject} c·ªßa {student.name} ƒë√£ thay ƒë·ªïi: {old_grade} ‚Üí {new_grade}")

class StatisticsService:
    """Service th·ªëng k√™."""
    
    def update(self, student, event_type, data):
        if event_type in ['grade_added', 'grade_updated']:
            print(f"üìä C·∫≠p nh·∫≠t th·ªëng k√™ cho {student.name}")

class ObservableStudent:
    """Student class v·ªõi Observer pattern."""
    
    def __init__(self, name, student_id):
        self.name = name
        self.student_id = student_id
        self.grades = {}
        self._observers: List[Observer] = []
    
    def add_observer(self, observer: Observer):
        """Th√™m observer."""
        self._observers.append(observer)
    
    def remove_observer(self, observer: Observer):
        """X√≥a observer."""
        if observer in self._observers:
            self._observers.remove(observer)
    
    def notify_observers(self, event_type, data):
        """Th√¥ng b√°o t·∫•t c·∫£ observers."""
        for observer in self._observers:
            observer.update(self, event_type, data)
    
    def add_grade(self, subject, grade):
        """Th√™m ƒëi·ªÉm v√† th√¥ng b√°o observers."""
        old_grade = self.grades.get(subject)
        self.grades[subject] = grade
        
        if old_grade is None:
            # ƒêi·ªÉm m·ªõi
            self.notify_observers('grade_added', {
                'subject': subject,
                'grade': grade
            })
        else:
            # C·∫≠p nh·∫≠t ƒëi·ªÉm
            self.notify_observers('grade_updated', {
                'subject': subject,
                'old_grade': old_grade,
                'new_grade': grade
            })

# S·ª≠ d·ª•ng Observer Pattern
student = ObservableStudent("Nguy·ªÖn VƒÉn An", "SV001")

# ƒêƒÉng k√Ω observers
notification_service = GradeNotificationService()
statistics_service = StatisticsService()

student.add_observer(notification_service)
student.add_observer(statistics_service)

# Th√™m ƒëi·ªÉm - s·∫Ω trigger notifications
student.add_grade("To√°n", 8.5)
student.add_grade("L√Ω", 9.0)
student.add_grade("To√°n", 9.0)  # Update ƒëi·ªÉm To√°n
```

---

## üöÄ 4. PERFORMANCE BEST PRACTICES

### Efficient Data Structures
```python
# ‚úÖ S·ª≠ d·ª•ng set cho membership testing
def find_students_by_ids(all_students, target_ids):
    """T√¨m h·ªçc sinh theo danh s√°ch IDs."""
    # Convert to set for O(1) lookup thay v√¨ O(n)
    target_ids_set = set(target_ids)
    
    found_students = []
    for student in all_students:
        if student.id in target_ids_set:  # O(1) instead of O(n)
            found_students.append(student)
    
    return found_students

# ‚úÖ S·ª≠ d·ª•ng dict cho lookup nhanh
def create_student_lookup(students):
    """T·∫°o lookup dictionary cho students."""
    return {student.id: student for student in students}

def find_student_by_id(student_lookup, student_id):
    """T√¨m student b·∫±ng lookup dict - O(1)."""
    return student_lookup.get(student_id)

# ‚úÖ List comprehension vs for loop
def get_passing_students_fast(students, min_grade=5.0):
    """L·∫•y danh s√°ch h·ªçc sinh ƒë·∫≠u - c√°ch nhanh."""
    return [
        student for student in students 
        if student.calculate_average() >= min_grade
    ]

# ‚úÖ Generator cho memory efficiency
def get_high_achievers(students, min_gpa=3.5):
    """Generator cho h·ªçc sinh gi·ªèi - ti·∫øt ki·ªám memory."""
    for student in students:
        if student.gpa >= min_gpa:
            yield student

# S·ª≠ d·ª•ng generator
high_achievers = get_high_achievers(all_students)
for student in high_achievers:  # Lazy evaluation
    print(f"High achiever: {student.name}")
```

### Caching v√† Memoization
```python
from functools import lru_cache, cache
from typing import Dict, Any
import time

class Student:
    def __init__(self, name, student_id):
        self.name = name
        self.student_id = student_id
        self.grades = {}
        self._cache = {}
    
    @lru_cache(maxsize=128)
    def calculate_gpa(self):
        """T√≠nh GPA v·ªõi caching."""
        # Expensive calculation
        time.sleep(0.1)  # Simulate slow calculation
        
        if not self.grades:
            return 0.0
        
        total_points = sum(self.grades.values()) 
        return total_points / len(self.grades)
    
    def add_grade(self, subject, grade):
        """Th√™m ƒëi·ªÉm v√† clear cache."""
        self.grades[subject] = grade
        # Clear cache khi data thay ƒë·ªïi
        self.calculate_gpa.cache_clear()
    
    def get_letter_grade(self):
        """L·∫•y ƒëi·ªÉm ch·ªØ v·ªõi manual caching."""
        cache_key = 'letter_grade'
        
        # Check cache
        if cache_key in self._cache:
            return self._cache[cache_key]
        
        # Calculate v√† cache
        gpa = self.calculate_gpa()
        if gpa >= 3.5:
            letter = 'A'
        elif gpa >= 2.5:
            letter = 'B'
        elif gpa >= 1.5:
            letter = 'C'
        else:
            letter = 'F'
        
        self._cache[cache_key] = letter
        return letter

# Global cache cho expensive operations
@cache  # Python 3.9+
def get_university_ranking(university_name):
    """L·∫•y ranking tr∆∞·ªùng ƒë·∫°i h·ªçc - cached."""
    # Simulate expensive API call
    time.sleep(2)
    return {"ranking": 100, "score": 85.5}

# Usage
student = Student("An", "SV001")
student.add_grade("Math", 3.5)
student.add_grade("Science", 4.0)

# First call - slow
start = time.time()
gpa1 = student.calculate_gpa()
print(f"First call: {time.time() - start:.2f}s")

# Second call - fast (cached)
start = time.time()
gpa2 = student.calculate_gpa()
print(f"Second call: {time.time() - start:.2f}s")
```

### Database Best Practices
```python
import sqlite3
from contextlib import contextmanager
from typing import List, Optional

class StudentDatabase:
    """Database operations v·ªõi best practices."""
    
    def __init__(self, db_path):
        self.db_path = db_path
        self.init_database()
    
    @contextmanager
    def get_connection(self):
        """Context manager cho database connection."""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row  # Enable dict-like access
        try:
            yield conn
        finally:
            conn.close()
    
    def init_database(self):
        """Kh·ªüi t·∫°o database v·ªõi indexes."""
        with self.get_connection() as conn:
            conn.execute('''
                CREATE TABLE IF NOT EXISTS students (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    student_id TEXT UNIQUE NOT NULL,
                    name TEXT NOT NULL,
                    email TEXT UNIQUE,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # T·∫°o indexes cho performance
            conn.execute('CREATE INDEX IF NOT EXISTS idx_student_id ON students(student_id)')
            conn.execute('CREATE INDEX IF NOT EXISTS idx_email ON students(email)')
            
            conn.commit()
    
    def add_students_batch(self, students_data):
        """Th√™m nhi·ªÅu students c√πng l√∫c - hi·ªáu qu·∫£ h∆°n."""
        with self.get_connection() as conn:
            conn.executemany('''
                INSERT OR IGNORE INTO students (student_id, name, email)
                VALUES (?, ?, ?)
            ''', students_data)
            conn.commit()
            return conn.total_changes
    
    def find_students_by_name_pattern(self, pattern):
        """T√¨m students theo pattern - s·ª≠ d·ª•ng prepared statement."""
        with self.get_connection() as conn:
            cursor = conn.execute('''
                SELECT * FROM students 
                WHERE name LIKE ? 
                ORDER BY name
            ''', (f'%{pattern}%',))
            return [dict(row) for row in cursor.fetchall()]
    
    def get_student_statistics(self):
        """L·∫•y th·ªëng k√™ v·ªõi single query."""
        with self.get_connection() as conn:
            cursor = conn.execute('''
                SELECT 
                    COUNT(*) as total_students,
                    COUNT(DISTINCT SUBSTR(student_id, 1, 2)) as departments,
                    MIN(created_at) as first_registration,
                    MAX(created_at) as last_registration
                FROM students
            ''')
            return dict(cursor.fetchone())
```

---

## üß™ 5. TESTING BEST PRACTICES

### Unit Testing
```python
import unittest
from unittest.mock import Mock, patch
import tempfile
import os

class TestStudent(unittest.TestCase):
    """Test cases cho Student class."""
    
    def setUp(self):
        """Setup ch·∫°y tr∆∞·ªõc m·ªói test."""
        self.student = Student("Nguy·ªÖn VƒÉn An", "SV001")
    
    def tearDown(self):
        """Cleanup sau m·ªói test."""
        # Cleanup n·∫øu c·∫ßn
        pass
    
    def test_student_creation(self):
        """Test t·∫°o student."""
        self.assertEqual(self.student.name, "Nguy·ªÖn VƒÉn An")
        self.assertEqual(self.student.student_id, "SV001")
        self.assertEqual(self.student.grades, {})
    
    def test_add_grade_valid(self):
        """Test th√™m ƒëi·ªÉm h·ª£p l·ªá."""
        self.student.add_grade("Math", 8.5)
        self.assertEqual(self.student.grades["Math"], 8.5)
    
    def test_add_grade_invalid(self):
        """Test th√™m ƒëi·ªÉm kh√¥ng h·ª£p l·ªá."""
        with self.assertRaises(ValueError):
            self.student.add_grade("Math", 11)  # > 10
        
        with self.assertRaises(ValueError):
            self.student.add_grade("Math", -1)  # < 0
    
    def test_calculate_average_empty(self):
        """Test t√≠nh trung b√¨nh khi ch∆∞a c√≥ ƒëi·ªÉm."""
        self.assertEqual(self.student.calculate_average(), 0.0)
    
    def test_calculate_average_with_grades(self):
        """Test t√≠nh trung b√¨nh c√≥ ƒëi·ªÉm."""
        self.student.add_grade("Math", 8.0)
        self.student.add_grade("Science", 9.0)
        self.assertAlmostEqual(self.student.calculate_average(), 8.5)
    
    @patch('builtins.print')  # Mock print function
    def test_display_info(self, mock_print):
        """Test display info v·ªõi mock."""
        self.student.display_info()
        mock_print.assert_called_once()
    
    def test_student_equality(self):
        """Test so s√°nh students."""
        student2 = Student("Nguy·ªÖn VƒÉn An", "SV001")
        self.assertEqual(self.student, student2)
        
        student3 = Student("Tr·∫ßn Th·ªã B", "SV002")
        self.assertNotEqual(self.student, student3)

class TestStudentDatabase(unittest.TestCase):
    """Test cases cho StudentDatabase."""
    
    def setUp(self):
        """Setup v·ªõi temporary database."""
        self.temp_db = tempfile.NamedTemporaryFile(delete=False)
        self.temp_db.close()
        self.db = StudentDatabase(self.temp_db.name)
    
    def tearDown(self):
        """Cleanup temporary database."""
        os.unlink(self.temp_db.name)
    
    def test_add_student(self):
        """Test th√™m student v√†o database."""
        student_data = ("SV001", "Nguy·ªÖn VƒÉn An", "an@example.com")
        changes = self.db.add_students_batch([student_data])
        self.assertEqual(changes, 1)
    
    def test_find_student_by_pattern(self):
        """Test t√¨m student theo pattern."""
        # Setup data
        students_data = [
            ("SV001", "Nguy·ªÖn VƒÉn An", "an@example.com"),
            ("SV002", "Tr·∫ßn Th·ªã B√¨nh", "binh@example.com"),
            ("SV003", "L√™ VƒÉn Chi", "chi@example.com")
        ]
        self.db.add_students_batch(students_data)
        
        # Test search
        results = self.db.find_students_by_name_pattern("VƒÉn")
        self.assertEqual(len(results), 2)  # An v√† Chi
        
        names = [student['name'] for student in results]
        self.assertIn("Nguy·ªÖn VƒÉn An", names)
        self.assertIn("L√™ VƒÉn Chi", names)

# Ch·∫°y tests
if __name__ == '__main__':
    unittest.main()
```

### Integration Testing
```python
import pytest
import requests_mock
import json

class TestStudentAPI:
    """Integration tests cho Student API."""
    
    @pytest.fixture
    def student_service(self):
        """Fixture cho StudentService."""
        return StudentService(base_url="https://api.example.com")
    
    def test_get_student_success(self, student_service):
        """Test l·∫•y th√¥ng tin student th√†nh c√¥ng."""
        with requests_mock.Mocker() as m:
            # Mock API response
            mock_response = {
                "id": "SV001",
                "name": "Nguy·ªÖn VƒÉn An",
                "email": "an@example.com"
            }
            m.get("https://api.example.com/students/SV001", json=mock_response)
            
            # Test
            student = student_service.get_student("SV001")
            assert student['name'] == "Nguy·ªÖn VƒÉn An"
            assert student['email'] == "an@example.com"
    
    def test_get_student_not_found(self, student_service):
        """Test student kh√¥ng t√¨m th·∫•y."""
        with requests_mock.Mocker() as m:
            m.get("https://api.example.com/students/SV999", status_code=404)
            
            with pytest.raises(StudentNotFoundError):
                student_service.get_student("SV999")
    
    @pytest.mark.parametrize("student_id,expected_department", [
        ("CS001", "Computer Science"),
        ("ME001", "Mechanical Engineering"),
        ("EE001", "Electrical Engineering")
    ])
    def test_get_department_by_id(self, student_id, expected_department):
        """Test l·∫•y department theo student ID pattern."""
        department = get_department_from_id(student_id)
        assert department == expected_department
```

---

## üîí 6. SECURITY BEST PRACTICES

### Input Sanitization
```python
import re
import html
from urllib.parse import quote

def sanitize_student_input(data):
    """Sanitize input data t·ª´ user."""
    sanitized = {}
    
    # Name sanitization
    if 'name' in data:
        name = str(data['name']).strip()
        # Remove potentially dangerous characters
        name = re.sub(r'[<>"\']', '', name)
        # Limit length
        sanitized['name'] = name[:100]
    
    # Email sanitization
    if 'email' in data:
        email = str(data['email']).strip().lower()
        # Basic email validation
        if re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', email):
            sanitized['email'] = email
        else:
            raise ValueError("Invalid email format")
    
    # Phone sanitization
    if 'phone' in data:
        phone = re.sub(r'[^\d+]', '', str(data['phone']))
        if len(phone) >= 10:
            sanitized['phone'] = phone
        else:
            raise ValueError("Invalid phone number")
    
    return sanitized

def escape_html_output(text):
    """Escape HTML ƒë·ªÉ tr√°nh XSS."""
    return html.escape(str(text))

def safe_filename(filename):
    """T·∫°o filename an to√†n."""
    # Remove path separators v√† special chars
    safe_name = re.sub(r'[^\w\-_\.]', '', filename)
    # Limit length
    return safe_name[:100]
```

### Configuration Management
```python
import os
from typing import Optional

class Config:
    """Configuration management v·ªõi environment variables."""
    
    def __init__(self):
        self.database_url = self._get_env_var('DATABASE_URL', 'sqlite:///default.db')
        self.secret_key = self._get_env_var('SECRET_KEY', required=True)
        self.debug = self._get_env_bool('DEBUG', False)
        self.max_file_size = self._get_env_int('MAX_FILE_SIZE', 16 * 1024 * 1024)
        self.allowed_origins = self._get_env_list('ALLOWED_ORIGINS', ['localhost'])
    
    def _get_env_var(self, key: str, default: Optional[str] = None, required: bool = False) -> str:
        """L·∫•y environment variable."""
        value = os.getenv(key, default)
        if required and not value:
            raise ValueError(f"Required environment variable {key} is not set")
        return value
    
    def _get_env_bool(self, key: str, default: bool = False) -> bool:
        """L·∫•y boolean environment variable."""
        value = os.getenv(key, '').lower()
        return value in ('true', '1', 'yes', 'on')
    
    def _get_env_int(self, key: str, default: int) -> int:
        """L·∫•y integer environment variable."""
        try:
            return int(os.getenv(key, str(default)))
        except ValueError:
            return default
    
    def _get_env_list(self, key: str, default: list) -> list:
        """L·∫•y list environment variable (comma-separated)."""
        value = os.getenv(key)
        if not value:
            return default
        return [item.strip() for item in value.split(',')]

# S·ª≠ d·ª•ng
config = Config()
```

### Logging Security
```python
import logging
import re
from logging.handlers import RotatingFileHandler

class SecureFormatter(logging.Formatter):
    """Formatter lo·∫°i b·ªè sensitive information."""
    
    def __init__(self):
        super().__init__(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        # Patterns ƒë·ªÉ ·∫©n sensitive data
        self.sensitive_patterns = [
            (re.compile(r'password["\']?\s*[:=]\s*["\']?([^"\'&\s]+)', re.IGNORECASE), 'password=***'),
            (re.compile(r'token["\']?\s*[:=]\s*["\']?([^"\'&\s]+)', re.IGNORECASE), 'token=***'),
            (re.compile(r'key["\']?\s*[:=]\s*["\']?([^"\'&\s]+)', re.IGNORECASE), 'key=***'),
            (re.compile(r'\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b'), '****-****-****-****'),  # Credit card
        ]
    
    def format(self, record):
        # Format message normally
        formatted = super().format(record)
        
        # Remove sensitive information
        for pattern, replacement in self.sensitive_patterns:
            formatted = pattern.sub(replacement, formatted)
        
        return formatted

def setup_secure_logging():
    """Setup logging v·ªõi security measures."""
    # Create logger
    logger = logging.getLogger('student_app')
    logger.setLevel(logging.INFO)
    
    # File handler v·ªõi rotation
    file_handler = RotatingFileHandler(
        'app.log',
        maxBytes=10*1024*1024,  # 10MB
        backupCount=5
    )
    file_handler.setFormatter(SecureFormatter())
    
    # Console handler
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(SecureFormatter())
    
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)
    
    return logger

# Usage
logger = setup_secure_logging()
logger.info("User login attempt: username=admin, password=secret123")
# Log output: "User login attempt: username=admin, password=***"
```

---

## üîó Li√™n K·∫øt ƒê·∫øn C√°c B√†i H·ªçc Kh√°c

- [üìã Python Cheatsheet](./python-cheatsheet.md) - B·∫£ng tra c·ª©u nhanh
- [üìê Quy t·∫Øc vi·∫øt code](./coding-style.md) - Coding style guide
- [‚ö° T·ªëi ∆∞u hi·ªáu su·∫•t](./performance-tips.md) - Performance optimization
- [üêõ Th√¥ng b√°o l·ªói](./error-messages.md) - Error handling

---

## üéØ T√≥m T·∫Øt

### üé® **Clean Code Principles:**
- **Single Responsibility** - M·ªói function l√†m m·ªôt vi·ªác
- **DRY** - Don't Repeat Yourself
- **KISS** - Keep It Simple, Stupid
- **Readable** - Code ph·∫£i d·ªÖ ƒë·ªçc nh∆∞ vƒÉn xu√¥i

### üõ°Ô∏è **Defensive Programming:**
- **Validate inputs** - Lu√¥n ki·ªÉm tra d·ªØ li·ªáu ƒë·∫ßu v√†o
- **Handle errors gracefully** - X·ª≠ l√Ω l·ªói m·ªôt c√°ch elegantly
- **Fail fast** - Ph√°t hi·ªán l·ªói s·ªõm nh·∫•t c√≥ th·ªÉ
- **Provide fallbacks** - Lu√¥n c√≥ plan B

### üé≠ **Design Patterns:**
- **Factory** - T·∫°o objects m·ªôt c√°ch linh ho·∫°t
- **Observer** - Loose coupling between components
- **Singleton** - ƒê·∫£m b·∫£o ch·ªâ c√≥ m·ªôt instance
- **Strategy** - Algorithms c√≥ th·ªÉ thay ƒë·ªïi ƒë∆∞·ª£c

### üöÄ **Performance:**
- **Choose right data structures** - set cho lookup, dict cho mapping
- **Use caching** - Cache expensive operations
- **Lazy evaluation** - Generators thay v√¨ lists khi c√≥ th·ªÉ
- **Database optimization** - Indexes, batch operations

### üß™ **Testing:**
- **Unit tests** - Test t·ª´ng component ri√™ng l·∫ª
- **Integration tests** - Test c√°c components work together
- **Mocking** - Isolate components under test
- **Parametrized tests** - Test nhi·ªÅu cases c√πng l√∫c

### üîí **Security:**
- **Validate v√† sanitize inputs** - Never trust user input
- **Environment variables** - Kh√¥ng hardcode secrets
- **Secure logging** - Mask sensitive information
- **Principle of least privilege** - Ch·ªâ cho permissions c·∫ßn thi·∫øt

### üí° **Golden Rules:**
1. **Code for humans** - Machines don't care, humans do
2. **Test early, test often** - Bugs are cheaper to fix early
3. **Measure before optimizing** - Don't guess, profile
4. **Security by design** - Not an afterthought
5. **Document your assumptions** - Future you will thank you

---

*üìù ƒê∆∞·ª£c c·∫≠p nh·∫≠t: Th√°ng 9, 2024*  
*üí° Tip: Best practices are guidelines, not laws - use judgment!*
