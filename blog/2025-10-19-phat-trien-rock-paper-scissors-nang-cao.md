---
slug: phat-trien-rock-paper-scissors-nang-cao
title: 'PhÃ¡t Triá»ƒn Rock-Paper-Scissors NÃ¢ng Cao - Tournament vÃ  AI ThÃ´ng Minh'
authors:
  - behitek
tags:
  - game-development
  - console-game
  - python
  - rock-paper-scissors
  - ai
  - tournament
  - statistics
description: >-
  NÃ¢ng cáº¥p game Rock-Paper-Scissors tá»« cÆ¡ báº£n thÃ nh há»‡ thá»‘ng tournament hoÃ n chá»‰nh vá»›i AI thÃ´ng minh, thá»‘ng kÃª chi tiáº¿t vÃ  nhiá»u cháº¿ Ä‘á»™ chÆ¡i thÃº vá»‹.
keywords: [rock paper scissors python, game kÃ©o bÃºa bao, AI game python, tournament system, machine learning game]
image: /img/blog/generated/phat-trien-rock-paper-scissors-nang-cao-thumbnail.jpg
---

Rock-Paper-Scissors (KÃ©o-BÃºa-Bao) tÆ°á»Ÿng chá»«ng Ä‘Æ¡n giáº£n nhÆ°ng áº©n chá»©a nhiá»u bÃ i há»c thÃº vá»‹ vá» láº­p trÃ¬nh AI, phÃ¢n tÃ­ch pattern, vÃ  xÃ¢y dá»±ng há»‡ thá»‘ng tournament. Trong bÃ i nÃ y, chÃºng ta sáº½ phÃ¡t triá»ƒn má»™t phiÃªn báº£n nÃ¢ng cao vá»›i AI thÃ´ng minh cÃ³ thá»ƒ há»c há»i tá»« lá»‘i chÆ¡i cá»§a báº¡n!

Dá»± Ã¡n nÃ y sáº½ dáº¡y chÃºng ta vá» machine learning cÆ¡ báº£n, pattern recognition, statistical analysis, vÃ  cÃ¡ch xÃ¢y dá»±ng má»™t há»‡ thá»‘ng game hoÃ n chá»‰nh tá»« A Ä‘áº¿n Z.

<!-- truncate -->

## Game Demo vÃ  Giá»›i Thiá»‡u

HÃ£y cÃ¹ng xem phiÃªn báº£n nÃ¢ng cao cá»§a Rock-Paper-Scissors:

```
ğŸ® â•â•â•â•â•â•â•â•â•â•â• ROCK-PAPER-SCISSORS CHAMPIONSHIP â•â•â•â•â•â•â•â•â•â•â• ğŸ®

ğŸ† Tournament Mode: Round Robin (8 players)
ğŸ¤– AI Level: Expert (Adaptive Learning)
ğŸ“Š Current Match: Player vs SmartAI

Round 15/20 
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     YOU         â”‚    SMART AI     â”‚
â”‚      âœ‚ï¸         â”‚       ğŸ—¿        â”‚
â”‚   (Scissors)    â”‚     (Rock)      â”‚
â”‚                 â”‚    ğŸ† WINS!     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ“ˆ Pattern Analysis:
   Your tendency: Rock(35%) > Scissors(35%) > Paper(30%)
   AI Prediction: Rock (Confidence: 78%)
   
ğŸ’¯ Score History: W-L-W-L-L-W-W-L-W-W-L-W-W-L-L
ğŸ¯ Win Rate: 53% | AI Win Rate: 47%

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. ğŸ—¿ Rock      3. ğŸ“Š View Stats
2. ğŸ“„ Paper     4. ğŸ¯ Strategy Hint  
3. âœ‚ï¸ Scissors  5. ğŸ”„ Change AI Level

Your choice: 
```

## Báº¡n Sáº½ Há»c ÄÆ°á»£c GÃ¬?

Qua dá»± Ã¡n nÃ¢ng cao nÃ y, báº¡n sáº½ thÃ nh tháº¡o:

- [x] **AI vÃ  Machine Learning**: Pattern recognition, adaptive algorithms
- [x] **Data Analysis**: Statistical analysis, trend prediction  
- [x] **Tournament Systems**: Round robin, elimination brackets
- [x] **Advanced OOP**: Strategy pattern, factory pattern, observer pattern
- [x] **Performance Optimization**: Caching, efficient data structures
- [x] **Visualization**: ASCII charts, progress bars, animated displays

## YÃªu Cáº§u TrÆ°á»›c Khi Báº¯t Äáº§u

- **Python trung cáº¥p**: OOP, decorators, generators
- **Math cÆ¡ báº£n**: Statistics, probability
- **Thuáº­t toÃ¡n**: Understanding cá»§a sorting, searching

:::info Game Modes Sáº½ XÃ¢y Dá»±ng
ğŸ¯ **Classic Mode**: ChÆ¡i Ä‘Æ¡n vá»›i AI  
ğŸ† **Tournament Mode**: Giáº£i Ä‘áº¥u nhiá»u ngÆ°á»i/AI  
ğŸ“Š **Training Mode**: AI há»c tá»« lá»‘i chÆ¡i cá»§a báº¡n  
ğŸ¤– **AI Battle**: Xem cÃ¡c AI Ä‘áº¥u vá»›i nhau  
ğŸ“ˆ **Analytics Mode**: PhÃ¢n tÃ­ch chi tiáº¿t patterns
:::

## Pháº§n 1: PhÃ¢n TÃ­ch Há»‡ Thá»‘ng NÃ¢ng Cao

### Game Flow Architecture

```mermaid
flowchart TD
    A[Start Application] --> B[Main Menu]
    B --> C{Choose Mode}
    C -->|Classic| D[Single Game vs AI]
    C -->|Tournament| E[Tournament Setup]
    C -->|Training| F[AI Training Mode]  
    C -->|Analytics| G[View Statistics]
    
    D --> H[Select AI Difficulty]
    H --> I[Play Rounds]
    I --> J[Update Stats]
    J --> K{Continue?}
    K -->|Yes| I
    K -->|No| B
    
    E --> L[Choose Tournament Type]
    L --> M[Add Participants]
    M --> N[Run Tournament]
    N --> O[Show Results]
    O --> B
    
    F --> P[AI Learning Phase]
    P --> Q[Test Learned Patterns]
    Q --> R[Export AI Model]
    R --> B
    
    G --> S[Generate Reports]
    S --> T[Display Charts]
    T --> B
```

### Component Architecture

```mermaid
classDiagram
    class GameEngine {
        -current_mode: str
        -tournament_manager: TournamentManager
        -ai_manager: AIManager
        -stats_tracker: StatsTracker
        +start_game()
        +switch_mode()
        +save_session()
    }
    
    class Player {
        -name: str
        -stats: PlayerStats
        -strategy: Strategy
        +make_move()
        +update_stats()
        +get_pattern()
    }
    
    class AIPlayer {
        -difficulty: int
        -learning_model: LearningModel
        -pattern_analyzer: PatternAnalyzer
        +predict_opponent_move()
        +adapt_strategy()
        +train_model()
    }
    
    class TournamentManager {
        -participants: list
        -tournament_type: str
        -bracket: Bracket
        +create_tournament()
        +run_round()
        +determine_winner()
    }
    
    class PatternAnalyzer {
        -move_history: list
        -patterns: dict
        +analyze_sequence()
        +predict_next_move()
        +calculate_confidence()
    }
    
    class StatsTracker {
        -global_stats: dict
        -session_stats: dict
        +record_move()
        +generate_report()
        +export_data()
    }
    
    GameEngine --> TournamentManager
    GameEngine --> AIPlayer
    GameEngine --> StatsTracker
    Player <|-- AIPlayer
    AIPlayer --> PatternAnalyzer
    TournamentManager --> Player
```

## Pháº§n 2: Core Game Implementation

### BÆ°á»›c 1: Base Classes vÃ  Enums

```python
from enum import Enum
import random
import time
from collections import defaultdict, deque
from abc import ABC, abstractmethod
import json
from datetime import datetime
import statistics

class Move(Enum):
    """Enum cho cÃ¡c nÆ°á»›c Ä‘i"""
    ROCK = "ğŸ—¿"
    PAPER = "ğŸ“„" 
    SCISSORS = "âœ‚ï¸"
    
    def beats(self, other):
        """Kiá»ƒm tra nÆ°á»›c Ä‘i nÃ y cÃ³ tháº¯ng nÆ°á»›c Ä‘i khÃ¡c khÃ´ng"""
        winning_combinations = {
            Move.ROCK: Move.SCISSORS,
            Move.PAPER: Move.ROCK,
            Move.SCISSORS: Move.PAPER
        }
        return winning_combinations[self] == other
    
    def __str__(self):
        return self.value

class GameResult(Enum):
    """Káº¿t quáº£ cá»§a má»™t round"""
    WIN = "WIN"
    LOSE = "LOSE"  
    DRAW = "DRAW"

class AILevel(Enum):
    """Má»©c Ä‘á»™ AI"""
    RANDOM = "Random"
    BASIC = "Basic Pattern"
    INTERMEDIATE = "Frequency Analysis"
    ADVANCED = "Markov Chain"
    EXPERT = "Adaptive Learning"
    MASTER = "Deep Pattern Recognition"

class PlayerStats:
    """Class theo dÃµi thá»‘ng kÃª cá»§a ngÆ°á»i chÆ¡i"""
    
    def __init__(self, name="Player"):
        self.name = name
        self.total_games = 0
        self.wins = 0
        self.losses = 0
        self.draws = 0
        self.move_history = deque(maxlen=1000)  # Giá»¯ 1000 nÆ°á»›c Ä‘i gáº§n nháº¥t
        self.move_counts = {Move.ROCK: 0, Move.PAPER: 0, Move.SCISSORS: 0}
        self.win_streaks = []
        self.current_streak = 0
        self.longest_streak = 0
        self.session_start = datetime.now()
    
    def record_game(self, my_move, opponent_move, result):
        """Ghi láº¡i káº¿t quáº£ má»™t game"""
        self.total_games += 1
        self.move_history.append((my_move, opponent_move, result, datetime.now()))
        self.move_counts[my_move] += 1
        
        if result == GameResult.WIN:
            self.wins += 1
            self.current_streak += 1
            self.longest_streak = max(self.longest_streak, self.current_streak)
        elif result == GameResult.LOSE:
            self.losses += 1
            if self.current_streak > 0:
                self.win_streaks.append(self.current_streak)
                self.current_streak = 0
        else:
            self.draws += 1
    
    def get_win_rate(self):
        """TÃ­nh tá»· lá»‡ tháº¯ng"""
        if self.total_games == 0:
            return 0
        return (self.wins / self.total_games) * 100
    
    def get_move_distribution(self):
        """PhÃ¢n bá»‘ cÃ¡c nÆ°á»›c Ä‘i"""
        if self.total_games == 0:
            return {move: 0 for move in Move}
        
        return {
            move: (count / self.total_games) * 100 
            for move, count in self.move_counts.items()
        }
    
    def get_recent_pattern(self, length=10):
        """Láº¥y pattern gáº§n Ä‘Ã¢y"""
        if len(self.move_history) < length:
            return [move for move, _, _, _ in self.move_history]
        return [move for move, _, _, _ in list(self.move_history)[-length:]]
    
    def to_dict(self):
        """Chuyá»ƒn thÃ nh dictionary Ä‘á»ƒ lÆ°u file"""
        return {
            'name': self.name,
            'total_games': self.total_games,
            'wins': self.wins,
            'losses': self.losses,
            'draws': self.draws,
            'move_counts': {move.name: count for move, count in self.move_counts.items()},
            'longest_streak': self.longest_streak,
            'session_start': self.session_start.isoformat()
        }
```

### BÆ°á»›c 2: Pattern Analysis Engine

```python
class PatternAnalyzer:
    """AI engine phÃ¢n tÃ­ch pattern cá»§a Ä‘á»‘i thá»§"""
    
    def __init__(self):
        self.move_history = deque(maxlen=100)
        self.sequence_patterns = defaultdict(lambda: defaultdict(int))
        self.frequency_analysis = {Move.ROCK: 0, Move.PAPER: 0, Move.SCISSORS: 0}
        self.markov_chain = defaultdict(lambda: defaultdict(int))
        self.adaptation_rate = 0.1
    
    def record_move(self, move):
        """Ghi láº¡i nÆ°á»›c Ä‘i cá»§a Ä‘á»‘i thá»§"""
        self.move_history.append(move)
        self.frequency_analysis[move] += 1
        
        # Cáº­p nháº­t Markov chain
        if len(self.move_history) >= 2:
            prev_move = self.move_history[-2]
            self.markov_chain[prev_move][move] += 1
        
        # PhÃ¢n tÃ­ch sequence patterns (2-4 moves)
        for seq_len in range(2, min(5, len(self.move_history) + 1)):
            if len(self.move_history) >= seq_len:
                sequence = tuple(list(self.move_history)[-seq_len:-1])
                next_move = self.move_history[-1]
                self.sequence_patterns[sequence][next_move] += 1
    
    def predict_next_move(self, method="combined"):
        """Dá»± Ä‘oÃ¡n nÆ°á»›c Ä‘i tiáº¿p theo"""
        if len(self.move_history) < 2:
            return random.choice(list(Move)), 0.33
        
        predictions = {}
        
        if method in ["frequency", "combined"]:
            predictions["frequency"] = self._frequency_prediction()
        
        if method in ["markov", "combined"]:
            predictions["markov"] = self._markov_prediction()
        
        if method in ["sequence", "combined"]:
            predictions["sequence"] = self._sequence_prediction()
        
        if method == "combined":
            return self._combine_predictions(predictions)
        else:
            pred_move, confidence = predictions.get(method, (random.choice(list(Move)), 0.33))
            return pred_move, confidence
    
    def _frequency_prediction(self):
        """Dá»± Ä‘oÃ¡n dá»±a trÃªn táº§n suáº¥t"""
        total_moves = sum(self.frequency_analysis.values())
        if total_moves == 0:
            return random.choice(list(Move)), 0.33
        
        # TÃ¬m move cÃ³ táº§n suáº¥t cao nháº¥t
        most_frequent = max(self.frequency_analysis, key=self.frequency_analysis.get)
        confidence = self.frequency_analysis[most_frequent] / total_moves
        
        return most_frequent, confidence
    
    def _markov_prediction(self):
        """Dá»± Ä‘oÃ¡n dá»±a trÃªn Markov chain"""
        if len(self.move_history) == 0:
            return random.choice(list(Move)), 0.33
        
        last_move = self.move_history[-1]
        transitions = self.markov_chain[last_move]
        
        if not transitions:
            return random.choice(list(Move)), 0.33
        
        total_transitions = sum(transitions.values())
        most_likely = max(transitions, key=transitions.get)
        confidence = transitions[most_likely] / total_transitions
        
        return most_likely, confidence
    
    def _sequence_prediction(self):
        """Dá»± Ä‘oÃ¡n dá»±a trÃªn sequence patterns"""
        best_prediction = None
        best_confidence = 0
        
        # Thá»­ cÃ¡c sequence lengths khÃ¡c nhau
        for seq_len in range(2, min(5, len(self.move_history) + 1)):
            if len(self.move_history) >= seq_len - 1:
                sequence = tuple(list(self.move_history)[-(seq_len-1):])
                
                if sequence in self.sequence_patterns:
                    patterns = self.sequence_patterns[sequence]
                    total_occurrences = sum(patterns.values())
                    
                    if total_occurrences > 0:
                        most_likely = max(patterns, key=patterns.get)
                        confidence = patterns[most_likely] / total_occurrences
                        
                        # Æ¯u tiÃªn sequence dÃ i hÆ¡n náº¿u confidence tÆ°Æ¡ng Ä‘Æ°Æ¡ng
                        if confidence > best_confidence or (
                            confidence == best_confidence and seq_len > len(sequence)
                        ):
                            best_prediction = most_likely
                            best_confidence = confidence
        
        if best_prediction:
            return best_prediction, best_confidence
        else:
            return random.choice(list(Move)), 0.33
    
    def _combine_predictions(self, predictions):
        """Káº¿t há»£p nhiá»u phÆ°Æ¡ng phÃ¡p dá»± Ä‘oÃ¡n"""
        if not predictions:
            return random.choice(list(Move)), 0.33
        
        # Weighted combination
        weights = {
            "sequence": 0.4,    # Æ¯u tiÃªn pattern sequences
            "markov": 0.35,     # Markov chain
            "frequency": 0.25   # Frequency analysis
        }
        
        combined_scores = defaultdict(float)
        total_weight = 0
        
        for method, (move, confidence) in predictions.items():
            if method in weights:
                weight = weights[method] * confidence
                combined_scores[move] += weight
                total_weight += weight
        
        if not combined_scores:
            return random.choice(list(Move)), 0.33
        
        # Normalize scores
        for move in combined_scores:
            combined_scores[move] /= total_weight
        
        best_move = max(combined_scores, key=combined_scores.get)
        best_confidence = combined_scores[best_move]
        
        return best_move, best_confidence
    
    def get_counter_move(self, predicted_move, confidence):
        """Láº¥y nÆ°á»›c Ä‘i counter láº¡i dá»± Ä‘oÃ¡n"""
        counter_moves = {
            Move.ROCK: Move.PAPER,
            Move.PAPER: Move.SCISSORS,
            Move.SCISSORS: Move.ROCK
        }
        
        # ThÃªm má»™t chÃºt randomness náº¿u confidence tháº¥p
        if confidence < 0.6 and random.random() < 0.3:
            return random.choice(list(Move))
        
        return counter_moves[predicted_move]
```

### BÆ°á»›c 3: AI Player Implementation

```python
class AIPlayer:
    """AI Player vá»›i nhiá»u má»©c Ä‘á»™ thÃ´ng minh khÃ¡c nhau"""
    
    def __init__(self, name, level=AILevel.INTERMEDIATE):
        self.name = name
        self.level = level
        self.stats = PlayerStats(name)
        self.pattern_analyzer = PatternAnalyzer()
        self.adaptation_counter = 0
        self.performance_history = deque(maxlen=20)
        
        # AI learning parameters
        self.learning_rate = 0.1
        self.exploration_rate = 0.2
        self.confidence_threshold = 0.7
    
    def make_move(self, opponent_history=None):
        """AI Ä‘Æ°a ra quyáº¿t Ä‘á»‹nh"""
        self.adaptation_counter += 1
        
        if self.level == AILevel.RANDOM:
            return self._random_move()
        elif self.level == AILevel.BASIC:
            return self._basic_pattern_move()
        elif self.level == AILevel.INTERMEDIATE:
            return self._frequency_analysis_move()
        elif self.level == AILevel.ADVANCED:
            return self._markov_chain_move()
        elif self.level == AILevel.EXPERT:
            return self._adaptive_learning_move()
        elif self.level == AILevel.MASTER:
            return self._deep_pattern_move()
        else:
            return self._random_move()
    
    def _random_move(self):
        """NÆ°á»›c Ä‘i ngáº«u nhiÃªn hoÃ n toÃ n"""
        return random.choice(list(Move))
    
    def _basic_pattern_move(self):
        """PhÃ¡t hiá»‡n pattern Ä‘Æ¡n giáº£n"""
        if len(self.pattern_analyzer.move_history) < 3:
            return random.choice(list(Move))
        
        # Kiá»ƒm tra pattern láº·p láº¡i Ä‘Æ¡n giáº£n
        recent_moves = list(self.pattern_analyzer.move_history)[-3:]
        if recent_moves[0] == recent_moves[1] == recent_moves[2]:
            # Äá»‘i thá»§ cÃ³ thá»ƒ sáº½ tiáº¿p tá»¥c pattern nÃ y
            predicted = recent_moves[0]
            return self.pattern_analyzer.get_counter_move(predicted, 0.6)
        
        return random.choice(list(Move))
    
    def _frequency_analysis_move(self):
        """PhÃ¢n tÃ­ch táº§n suáº¥t vÃ  counter"""
        predicted_move, confidence = self.pattern_analyzer.predict_next_move("frequency")
        
        if confidence > 0.4:
            return self.pattern_analyzer.get_counter_move(predicted_move, confidence)
        else:
            return random.choice(list(Move))
    
    def _markov_chain_move(self):
        """Sá»­ dá»¥ng Markov chain Ä‘á»ƒ dá»± Ä‘oÃ¡n"""
        predicted_move, confidence = self.pattern_analyzer.predict_next_move("markov")
        
        # ThÃªm má»™t chÃºt exploration
        if random.random() < self.exploration_rate:
            return random.choice(list(Move))
        
        return self.pattern_analyzer.get_counter_move(predicted_move, confidence)
    
    def _adaptive_learning_move(self):
        """AI há»c thÃ­ch á»©ng tá»« performance"""
        predicted_move, confidence = self.pattern_analyzer.predict_next_move("combined")
        
        # Äiá»u chá»‰nh strategy dá»±a trÃªn performance gáº§n Ä‘Ã¢y
        if len(self.performance_history) >= 5:
            recent_performance = sum(self.performance_history[-5:]) / 5
            
            if recent_performance < 0.4:  # Äang thua nhiá»u
                # TÄƒng exploration vÃ  thá»­ phÆ°Æ¡ng phÃ¡p khÃ¡c
                self.exploration_rate = min(0.4, self.exploration_rate + 0.05)
                if random.random() < 0.3:
                    return random.choice(list(Move))
            else:  # Äang tháº¯ng
                # Giáº£m exploration, tin tÆ°á»Ÿng vÃ o prediction
                self.exploration_rate = max(0.1, self.exploration_rate - 0.02)
        
        if confidence > self.confidence_threshold:
            return self.pattern_analyzer.get_counter_move(predicted_move, confidence)
        else:
            # Exploration move
            if random.random() < self.exploration_rate:
                return random.choice(list(Move))
            return self.pattern_analyzer.get_counter_move(predicted_move, confidence)
    
    def _deep_pattern_move(self):
        """AI master vá»›i deep pattern recognition"""
        # Káº¿t há»£p nhiá»u phÆ°Æ¡ng phÃ¡p vÃ  meta-learning
        predictions = {}
        
        # Multiple prediction methods
        for method in ["frequency", "markov", "sequence"]:
            move, conf = self.pattern_analyzer.predict_next_move(method)
            predictions[method] = (move, conf)
        
        # Meta-analysis: which method has been most accurate recently?
        method_weights = self._calculate_method_weights()
        
        # Weighted prediction
        final_prediction = self._weighted_prediction(predictions, method_weights)
        
        # Advanced counter-strategy
        return self._advanced_counter_strategy(final_prediction)
    
    def _calculate_method_weights(self):
        """TÃ­nh trá»ng sá»‘ cho cÃ¡c phÆ°Æ¡ng phÃ¡p dá»± Ä‘oÃ¡n"""
        # Simplified version - trong thá»±c táº¿ sáº½ track accuracy cá»§a tá»«ng method
        return {
            "sequence": 0.4,
            "markov": 0.35,
            "frequency": 0.25
        }
    
    def _weighted_prediction(self, predictions, weights):
        """Káº¿t há»£p predictions vá»›i trá»ng sá»‘"""
        move_scores = defaultdict(float)
        
        for method, (move, confidence) in predictions.items():
            weight = weights.get(method, 0.33)
            move_scores[move] += confidence * weight
        
        if move_scores:
            best_move = max(move_scores, key=move_scores.get)
            best_confidence = move_scores[best_move]
            return best_move, best_confidence
        else:
            return random.choice(list(Move)), 0.33
    
    def _advanced_counter_strategy(self, prediction):
        """Chiáº¿n thuáº­t counter nÃ¢ng cao"""
        predicted_move, confidence = prediction
        
        # Level 1: Direct counter
        if confidence > 0.8:
            return self.pattern_analyzer.get_counter_move(predicted_move, confidence)
        
        # Level 2: Meta-gaming (Ä‘á»‘i thá»§ cÃ³ thá»ƒ biáº¿t mÃ¬nh sáº½ counter)
        elif confidence > 0.6:
            if random.random() < 0.3:  # 30% chance meta-game
                # Counter the counter
                counter_move = self.pattern_analyzer.get_counter_move(predicted_move, confidence)
                return self.pattern_analyzer.get_counter_move(counter_move, confidence)
            else:
                return self.pattern_analyzer.get_counter_move(predicted_move, confidence)
        
        # Level 3: Mixed strategy khi khÃ´ng cháº¯c cháº¯n
        else:
            return random.choice(list(Move))
    
    def update_opponent_move(self, opponent_move, result):
        """Cáº­p nháº­t thÃ´ng tin vá» nÆ°á»›c Ä‘i cá»§a Ä‘á»‘i thá»§"""
        self.pattern_analyzer.record_move(opponent_move)
        
        # Ghi láº¡i performance Ä‘á»ƒ adaptive learning
        performance_score = 1.0 if result == GameResult.WIN else (0.5 if result == GameResult.DRAW else 0.0)
        self.performance_history.append(performance_score)
        
        # Update stats
        my_move = None  # Cáº§n track move cá»§a AI
        self.stats.record_game(my_move, opponent_move, result)
    
    def get_strategy_info(self):
        """Láº¥y thÃ´ng tin vá» chiáº¿n thuáº­t hiá»‡n táº¡i"""
        info = {
            "level": self.level.value,
            "exploration_rate": self.exploration_rate,
            "confidence_threshold": self.confidence_threshold,
            "games_analyzed": len(self.pattern_analyzer.move_history),
            "current_performance": sum(self.performance_history) / len(self.performance_history) if self.performance_history else 0
        }
        
        if len(self.pattern_analyzer.move_history) > 0:
            predicted_move, confidence = self.pattern_analyzer.predict_next_move()
            info["next_prediction"] = predicted_move.name
            info["prediction_confidence"] = confidence
        
        return info
```

### BÆ°á»›c 4: Game Engine vÃ  Display

```python
class GameDisplay:
    """Class xá»­ lÃ½ hiá»ƒn thá»‹ game"""
    
    @staticmethod
    def clear_screen():
        """XÃ³a mÃ n hÃ¬nh"""
        import os
        os.system('cls' if os.name == 'nt' else 'clear')
    
    @staticmethod
    def display_title():
        """Hiá»ƒn thá»‹ title"""
        print("ğŸ® â•â•â•â•â•â•â•â•â•â•â• ROCK-PAPER-SCISSORS CHAMPIONSHIP â•â•â•â•â•â•â•â•â•â•â• ğŸ®")
        print()
    
    @staticmethod
    def display_round_result(player_move, ai_move, result, round_num):
        """Hiá»ƒn thá»‹ káº¿t quáº£ round"""
        print(f"\nğŸ¯ Round {round_num}")
        print("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”")
        print("â”‚     YOU         â”‚    OPPONENT     â”‚")
        print(f"â”‚      {player_move}         â”‚       {ai_move}        â”‚")
        print(f"â”‚   ({player_move.name.title()})    â”‚     ({ai_move.name.title()})      â”‚")
        
        if result == GameResult.WIN:
            print("â”‚    ğŸ† WINS!     â”‚                 â”‚")
        elif result == GameResult.LOSE:
            print("â”‚                 â”‚    ğŸ† WINS!     â”‚")
        else:
            print("â”‚    ğŸ¤ DRAW      â”‚    ğŸ¤ DRAW      â”‚")
        
        print("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")
    
    @staticmethod
    def display_stats(stats, ai_stats=None):
        """Hiá»ƒn thá»‹ thá»‘ng kÃª"""
        print(f"\nğŸ“Š Your Stats:")
        print(f"   Games: {stats.total_games} | W: {stats.wins} | L: {stats.losses} | D: {stats.draws}")
        print(f"   Win Rate: {stats.get_win_rate():.1f}% | Streak: {stats.current_streak}")
        
        distribution = stats.get_move_distribution()
        print(f"   Moves: ğŸ—¿{distribution[Move.ROCK]:.0f}% ğŸ“„{distribution[Move.PAPER]:.0f}% âœ‚ï¸{distribution[Move.SCISSORS]:.0f}%")
        
        if ai_stats:
            print(f"\nğŸ¤– AI Stats:")
            print(f"   Games: {ai_stats.total_games} | W: {ai_stats.wins} | Win Rate: {ai_stats.get_win_rate():.1f}%")
    
    @staticmethod
    def display_pattern_analysis(analyzer):
        """Hiá»ƒn thá»‹ phÃ¢n tÃ­ch pattern"""
        if len(analyzer.move_history) < 3:
            return
        
        print(f"\nğŸ“ˆ Pattern Analysis:")
        
        # Recent moves
        recent = list(analyzer.move_history)[-10:]
        recent_str = " â†’ ".join([move.value for move in recent])
        print(f"   Recent: {recent_str}")
        
        # Frequency analysis
        total = sum(analyzer.frequency_analysis.values())
        if total > 0:
            freq_str = " | ".join([
                f"{move.value}({count/total*100:.0f}%)" 
                for move, count in analyzer.frequency_analysis.items()
            ])
            print(f"   Frequency: {freq_str}")
        
        # Prediction
        predicted_move, confidence = analyzer.predict_next_move()
        print(f"   AI Prediction: {predicted_move.value} (Confidence: {confidence*100:.0f}%)")
    
    @staticmethod
    def display_menu():
        """Hiá»ƒn thá»‹ menu chÃ­nh"""
        print("\nğŸ® Main Menu:")
        print("1. ğŸ¯ Classic Game")
        print("2. ğŸ† Tournament Mode") 
        print("3. ğŸ¤– AI Training")
        print("4. ğŸ“Š View Statistics")
        print("5. âš™ï¸ Settings")
        print("6. ğŸšª Exit")
    
    @staticmethod
    def display_game_menu():
        """Hiá»ƒn thá»‹ menu trong game"""
        print("\nğŸ“‹ Your move:")
        print("1. ğŸ—¿ Rock")
        print("2. ğŸ“„ Paper")
        print("3. âœ‚ï¸ Scissors")
        print("4. ğŸ“Š View Stats")
        print("5. ğŸ¯ Strategy Hint")
        print("6. ğŸ”„ Change AI Level")
        print("7. ğŸƒ Quit to Menu")

class RockPaperScissorsGame:
    """Game engine chÃ­nh"""
    
    def __init__(self):
        self.player_stats = PlayerStats("Player")
        self.ai_player = AIPlayer("SmartAI", AILevel.INTERMEDIATE)
        self.current_round = 0
        self.session_stats = {
            'start_time': datetime.now(),
            'games_played': 0,
            'different_ais_faced': set()
        }
        self.display = GameDisplay()
    
    def start(self):
        """Báº¯t Ä‘áº§u game"""
        self.display.clear_screen()
        self.display.display_title()
        
        print("ğŸŒŸ Welcome to Rock-Paper-Scissors Championship!")
        print("   Advanced AI â€¢ Pattern Analysis â€¢ Tournament Mode")
        
        while True:
            self.display.display_menu()
            choice = input("\nChoose an option: ").strip()
            
            if choice == '1':
                self.play_classic_game()
            elif choice == '2':
                self.tournament_mode()
            elif choice == '3':
                self.ai_training_mode()
            elif choice == '4':
                self.view_statistics()
            elif choice == '5':
                self.settings_menu()
            elif choice == '6':
                print("ğŸ‘‹ Thanks for playing! See you next time!")
                break
            else:
                print("âŒ Invalid choice! Please try again.")
                time.sleep(1)
    
    def play_classic_game(self):
        """ChÆ¡i game classic vá»›i AI"""
        self.display.clear_screen()
        print("ğŸ¯ Classic Game Mode")
        print(f"ğŸ¤– Current AI: {self.ai_player.name} ({self.ai_player.level.value})")
        
        rounds_to_play = self.get_rounds_input()
        if rounds_to_play is None:
            return
        
        round_count = 0
        
        while round_count < rounds_to_play:
            self.display.clear_screen()
            self.display.display_title()
            print(f"ğŸ¯ Round {round_count + 1}/{rounds_to_play}")
            
            # Hiá»ƒn thá»‹ stats vÃ  pattern analysis
            if round_count > 0:
                self.display.display_stats(self.player_stats, self.ai_player.stats)
                self.display.display_pattern_analysis(self.ai_player.pattern_analyzer)
            
            self.display.display_game_menu()
            choice = input("\nYour choice: ").strip()
            
            if choice in ['1', '2', '3']:
                moves = {
                    '1': Move.ROCK,
                    '2': Move.PAPER, 
                    '3': Move.SCISSORS
                }
                player_move = moves[choice]
                
                # AI makes move
                ai_move = self.ai_player.make_move()
                
                # Determine result
                result = self.determine_result(player_move, ai_move)
                
                # Update stats
                self.update_game_stats(player_move, ai_move, result)
                
                # Display result
                self.display.display_round_result(player_move, ai_move, result, round_count + 1)
                
                round_count += 1
                
                if round_count < rounds_to_play:
                    input("\nPress Enter to continue...")
                
            elif choice == '4':
                self.show_detailed_stats()
            elif choice == '5':
                self.show_strategy_hint()
            elif choice == '6':
                self.change_ai_level()
            elif choice == '7':
                break
            else:
                print("âŒ Invalid choice!")
                time.sleep(1)
        
        # Show final results
        if round_count > 0:
            self.show_game_summary(rounds_to_play)
    
    def determine_result(self, player_move, ai_move):
        """XÃ¡c Ä‘á»‹nh káº¿t quáº£ game"""
        if player_move == ai_move:
            return GameResult.DRAW
        elif player_move.beats(ai_move):
            return GameResult.WIN
        else:
            return GameResult.LOSE
    
    def update_game_stats(self, player_move, ai_move, result):
        """Cáº­p nháº­t thá»‘ng kÃª"""
        self.player_stats.record_game(player_move, ai_move, result)
        
        # Update AI
        ai_result = GameResult.LOSE if result == GameResult.WIN else (
            GameResult.WIN if result == GameResult.LOSE else GameResult.DRAW
        )
        self.ai_player.update_opponent_move(player_move, ai_result)
        self.ai_player.stats.record_game(ai_move, player_move, ai_result)
        
        self.session_stats['games_played'] += 1
        self.session_stats['different_ais_faced'].add(self.ai_player.name)
    
    def get_rounds_input(self):
        """Láº¥y sá»‘ rounds muá»‘n chÆ¡i"""
        while True:
            try:
                rounds = input("How many rounds? (1-100, or 'back' to return): ").strip()
                if rounds.lower() == 'back':
                    return None
                rounds = int(rounds)
                if 1 <= rounds <= 100:
                    return rounds
                else:
                    print("âŒ Please enter a number between 1 and 100!")
            except ValueError:
                print("âŒ Please enter a valid number!")
    
    def show_detailed_stats(self):
        """Hiá»ƒn thá»‹ thá»‘ng kÃª chi tiáº¿t"""
        self.display.clear_screen()
        print("ğŸ“Š â•â•â• DETAILED STATISTICS â•â•â•")
        
        # Player stats
        print(f"\nğŸ‘¤ Player Stats:")
        print(f"   Total Games: {self.player_stats.total_games}")
        print(f"   Wins: {self.player_stats.wins} ({self.player_stats.get_win_rate():.1f}%)")
        print(f"   Losses: {self.player_stats.losses}")
        print(f"   Draws: {self.player_stats.draws}")
        print(f"   Current Streak: {self.player_stats.current_streak}")
        print(f"   Longest Streak: {self.player_stats.longest_streak}")
        
        # Move distribution
        dist = self.player_stats.get_move_distribution()
        print(f"\nğŸ¯ Move Distribution:")
        for move, percentage in dist.items():
            print(f"   {move.value} {move.name}: {percentage:.1f}%")
        
        # AI stats  
        print(f"\nğŸ¤– AI Stats:")
        ai_info = self.ai_player.get_strategy_info()
        for key, value in ai_info.items():
            print(f"   {key.replace('_', ' ').title()}: {value}")
        
        input("\nPress Enter to continue...")
    
    def show_strategy_hint(self):
        """Hiá»ƒn thá»‹ gá»£i Ã½ chiáº¿n thuáº­t"""
        if len(self.ai_player.pattern_analyzer.move_history) < 3:
            print("\nğŸ’¡ Not enough data for analysis yet. Play more rounds!")
        else:
            predicted_move, confidence = self.ai_player.pattern_analyzer.predict_next_move()
            counter_move = self.ai_player.pattern_analyzer.get_counter_move(predicted_move, confidence)
            
            print(f"\nğŸ’¡ Strategy Hint:")
            print(f"   AI predicts you'll play: {predicted_move.value} ({confidence*100:.0f}% confidence)")
            print(f"   Suggested counter: {counter_move.value}")
            
            # Additional advice
            if confidence > 0.7:
                print(f"   ğŸ’ª High confidence prediction - consider the counter!")
            elif confidence > 0.5:
                print(f"   ğŸ¤” Medium confidence - mix up your strategy")
            else:
                print(f"   ğŸ² Low confidence - your pattern is unpredictable!")
        
        input("\nPress Enter to continue...")
    
    def change_ai_level(self):
        """Thay Ä‘á»•i má»©c Ä‘á»™ AI"""
        print("\nğŸ”§ Choose AI Level:")
        levels = list(AILevel)
        for i, level in enumerate(levels, 1):
            current = " (Current)" if level == self.ai_player.level else ""
            print(f"   {i}. {level.value}{current}")
        
        try:
            choice = int(input("\nSelect level (1-6): ")) - 1
            if 0 <= choice < len(levels):
                old_level = self.ai_player.level
                self.ai_player.level = levels[choice]
                print(f"âœ… AI level changed from {old_level.value} to {levels[choice].value}")
            else:
                print("âŒ Invalid choice!")
        except ValueError:
            print("âŒ Please enter a number!")
        
        time.sleep(2)
    
    def show_game_summary(self, total_rounds):
        """Hiá»ƒn thá»‹ tá»•ng káº¿t game"""
        self.display.clear_screen()
        print("ğŸ â•â•â• GAME SUMMARY â•â•â•")
        
        print(f"\nğŸ“Š Results after {total_rounds} rounds:")
        print(f"   Your wins: {self.player_stats.wins}")
        print(f"   AI wins: {self.ai_player.stats.wins}")
        print(f"   Draws: {self.player_stats.draws}")
        
        if self.player_stats.wins > self.ai_player.stats.wins:
            print("\nğŸ‰ Congratulations! You won the match!")
        elif self.player_stats.wins < self.ai_player.stats.wins:
            print("\nğŸ¤– AI wins this match! Better luck next time!")
        else:
            print("\nğŸ¤ It's a tie! Great match!")
        
        print(f"\nğŸ“ˆ Your final win rate: {self.player_stats.get_win_rate():.1f}%")
        
        input("\nPress Enter to return to menu...")
    
    def tournament_mode(self):
        """Cháº¿ Ä‘á»™ tournament (simplified for now)"""
        print("\nğŸ† Tournament Mode - Coming Soon!")
        print("   Features in development:")
        print("   â€¢ Round Robin tournaments")
        print("   â€¢ Elimination brackets") 
        print("   â€¢ Multiple AI opponents")
        print("   â€¢ Leaderboards")
        
        input("\nPress Enter to return to menu...")
    
    def ai_training_mode(self):
        """Cháº¿ Ä‘á»™ training AI"""
        print("\nğŸ¤– AI Training Mode - Coming Soon!")
        print("   Features in development:")
        print("   â€¢ Train AI with your playing style")
        print("   â€¢ Export/Import AI models")
        print("   â€¢ Create custom AI opponents")
        
        input("\nPress Enter to return to menu...")
    
    def view_statistics(self):
        """Xem thá»‘ng kÃª tá»•ng quÃ¡t"""
        self.show_detailed_stats()
    
    def settings_menu(self):
        """Menu cÃ i Ä‘áº·t"""
        print("\nâš™ï¸ Settings - Coming Soon!")
        print("   â€¢ Save/Load game data")
        print("   â€¢ Customize display")
        print("   â€¢ Export statistics")
        
        input("\nPress Enter to return to menu...")

if __name__ == "__main__":
    game = RockPaperScissorsGame()
    game.start()
```

## Pháº§n 3: Tournament System (Preview)

### Tournament Manager

```python
class TournamentManager:
    """Quáº£n lÃ½ há»‡ thá»‘ng tournament"""
    
    def __init__(self):
        self.participants = []
        self.tournament_type = None
        self.results = []
        
    def create_round_robin(self, participants):
        """Táº¡o tournament round robin"""
        matches = []
        for i in range(len(participants)):
            for j in range(i + 1, len(participants)):
                matches.append((participants[i], participants[j]))
        return matches
    
    def create_elimination(self, participants):
        """Táº¡o tournament elimination"""
        # Implementation for elimination brackets
        pass
    
    def run_tournament(self):
        """Cháº¡y tournament"""
        # Implementation for running matches
        pass
```

## Pháº§n 4: Advanced Features (Preview)

### Machine Learning Integration

```python
import numpy as np
from sklearn.naive_bayes import MultinomialNB

class MLPredictor:
    """Machine Learning predictor cho nÃ¢ng cao hÆ¡n"""
    
    def __init__(self):
        self.model = MultinomialNB()
        self.is_trained = False
        self.feature_history = []
        self.target_history = []
    
    def extract_features(self, move_history):
        """TrÃ­ch xuáº¥t features tá»« lá»‹ch sá»­ moves"""
        # Convert moves to numerical features
        # Implementation tÃ¹y thuá»™c vÃ o strategy
        pass
    
    def train(self, training_data):
        """Train model vá»›i dá»¯ liá»‡u"""
        # Implementation for ML training
        pass
    
    def predict(self, current_features):
        """Dá»± Ä‘oÃ¡n move tiáº¿p theo"""
        # Implementation for prediction
        pass
```

## Thá»­ ThÃ¡ch Cho Báº¡n

HÃ£y má»Ÿ rá»™ng game vá»›i nhá»¯ng tÃ­nh nÄƒng nÃ y:

- [ ] **Tournament System**: HoÃ n thiá»‡n round robin vÃ  elimination brackets
- [ ] **Machine Learning**: TÃ­ch há»£p scikit-learn cho prediction nÃ¢ng cao
- [ ] **Multiplayer Online**: ChÆ¡i qua máº¡ng vá»›i socket programming
- [ ] **GUI Version**: Táº¡o giao diá»‡n Ä‘á»“ há»a vá»›i Tkinter/Pygame
- [ ] **Statistics Dashboard**: Biá»ƒu Ä‘á»“ vÃ  visualization vá»›i matplotlib
- [ ] **AI Personality**: Táº¡o AI vá»›i cÃ¡c "tÃ­nh cÃ¡ch" chÆ¡i khÃ¡c nhau
- [ ] **Voice Control**: Äiá»u khiá»ƒn báº±ng giá»ng nÃ³i
- [ ] **Mobile App**: Port sang Android/iOS

## Source Code vÃ  Resources

:::tip TÃ i NguyÃªn Há»c Táº­p
**GitHub Repository**: [rps-championship-python](https://github.com/behitek/rps-championship-python)  
**Documentation**: HÆ°á»›ng dáº«n chi tiáº¿t tá»«ng component  
**Video Series**: Playlist giáº£i thÃ­ch cÃ¡c algorithms  
:::

## BÃ i Tiáº¿p Theo

Trong bÃ i tiáº¿p theo, chÃºng ta sáº½ há»c cÃ¡ch **"Táº¡o Text Adventure Game"** - xÃ¢y dá»±ng tháº¿ giá»›i game RPG vá»›i story branching, inventory system vÃ  quest management!

:::note Káº¿t Luáº­n
Rock-Paper-Scissors tÆ°á»Ÿng Ä‘Æ¡n giáº£n nhÆ°ng Ä‘Ã£ dáº¡y chÃºng ta ráº¥t nhiá»u vá» AI, pattern recognition, vÃ  system design. Tá»« game cÆ¡ báº£n, chÃºng ta Ä‘Ã£ xÃ¢y dá»±ng má»™t há»‡ thá»‘ng hoÃ n chá»‰nh vá»›i nhiá»u tÃ­nh nÄƒng nÃ¢ng cao. ÄÃ¢y lÃ  bÆ°á»›c Ä‘á»‡m tuyá»‡t vá»i cho viá»‡c phÃ¡t triá»ƒn AI game phá»©c táº¡p hÆ¡n!
:::

ChÃºc báº¡n coding vui váº» vÃ  chiáº¿n tháº¯ng má»i AI! ğŸš€ğŸ¤–